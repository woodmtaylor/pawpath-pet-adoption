=== ./backend/src/middleware/AuthMiddleware.php ===
<?php
// backend/src/middleware/AuthMiddleware.php

namespace PawPath\middleware;

use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\RequestHandlerInterface as RequestHandler;
use Slim\Psr7\Response;
use PawPath\services\AuthService;  // Changed from PawPath\Services\AuthService

class AuthMiddleware
{
    private AuthService $authService;
    
    public function __construct()
    {
        $this->authService = new AuthService();
    }
    
    public function __invoke(Request $request, RequestHandler $handler): Response
    {
        $token = $this->extractToken($request);
        
        if (!$token) {
            $response = new Response();
            $response->getBody()->write(json_encode([
                'error' => 'No token provided'
            ]));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        
        $payload = $this->authService->validateToken($token);
        
        if (!$payload) {
            $response = new Response();
            $response->getBody()->write(json_encode([
                'error' => 'Invalid token'
            ]));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        
        // Add user to request attributes
        $request = $request->withAttribute('user_id', $payload['user_id']);
        
        return $handler->handle($request);
    }
    
    private function extractToken(Request $request): ?string
    {
        $header = $request->getHeaderLine('Authorization');
        
        if (empty($header)) {
            return null;
        }
        
        if (preg_match('/Bearer\s+(.*)$/i', $header, $matches)) {
            return $matches[1];
        }
        
        return null;
    }
}
=== ./backend/src/config/database/DatabaseConfig.php ===
<?php
// backend/src/config/database/DatabaseConfig.php

namespace PawPath\config\database;

use PDO;
use PDOException;

class DatabaseConfig {
    private static ?PDO $connection = null;
    
    public static function getConnection(): PDO {
        if (self::$connection === null) {
            try {
                // Get environment variables
                $dotenv = \Dotenv\Dotenv::createImmutable(__DIR__ . '/../../../');
                $dotenv->load();

                // Debug environment variables
                error_log("Environment variables:");
                error_log("DB_HOST: " . ($_ENV['DB_HOST'] ?? 'not set'));
                error_log("DB_PORT: " . ($_ENV['DB_PORT'] ?? 'not set'));
                error_log("DB_DATABASE: " . ($_ENV['DB_DATABASE'] ?? 'not set'));
                error_log("DB_USERNAME: " . ($_ENV['DB_USERNAME'] ?? 'not set'));
                error_log("DB_PASSWORD is set: " . (isset($_ENV['DB_PASSWORD']) ? 'Yes' : 'No'));
                
                // Use exact matches to your .env file
                $host = $_ENV['DB_HOST'] ?? 'localhost';
                $port = $_ENV['DB_PORT'] ?? '3306';
                $dbName = $_ENV['DB_DATABASE'] ?? 'pawpath';
                $username = $_ENV['DB_USERNAME'] ?? 'root';
                $password = $_ENV['DB_PASSWORD'] ?? '';
                
                $dsn = "mysql:host=$host;port=$port;dbname=$dbName;charset=utf8mb4";
                
                error_log("Attempting to connect with DSN: $dsn");
                error_log("Username: $username");
                
                self::$connection = new PDO(
                    $dsn,
                    $username,
                    $password,
                    [
                        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                        PDO::ATTR_EMULATE_PREPARES => false
                    ]
                );
                
                error_log("Database connection successful");
            } catch (PDOException $e) {
                error_log("Database connection failed: " . $e->getMessage());
                throw new PDOException("Connection failed: " . $e->getMessage());
            }
        }
        
        return self::$connection;
    }
}
=== ./backend/src/config/README.md ===
# Config Directory
Contains configuration files for:
- Database
- Authentication
- Email
- External Services
=== ./backend/src/api/PetController.php ===
<?php
// backend/src/api/PetController.php

namespace PawPath\api;

use PawPath\services\PetService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

class PetController {
    private PetService $petService;
    
    public function __construct() {
        $this->petService = new PetService();
    }
    
    public function createPet(Request $request, Response $response): Response {
        try {
            $data = $request->getParsedBody();
            error_log('Creating pet with data: ' . print_r($data, true));
            
            if (!is_array($data)) {
                $body = (string) $request->getBody();
                $data = json_decode($body, true);
                error_log('Parsed JSON data: ' . print_r($data, true));
                
                if (json_last_error() !== JSON_ERROR_NONE) {
                    throw new \RuntimeException('Invalid JSON data provided: ' . json_last_error_msg());
                }
            }
            
            if (empty($data)) {
                throw new \RuntimeException('No data provided');
            }
            
            $result = $this->petService->createPet($data);
            error_log('Pet creation result: ' . print_r($result, true));
            
            $response->getBody()->write(json_encode([
                'success' => true,
                'data' => $result
            ]));
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(201);
        } catch (\Exception $e) {
            error_log('Error creating pet: ' . $e->getMessage() . "\n" . $e->getTraceAsString());
            
            $response->getBody()->write(json_encode([
                'success' => false,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString() // Remove in production
            ]));
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(400);
        }
    }
       
    public function getPet(Request $request, Response $response, array $args): Response {
        try {
            $petId = (int) $args['id'];
            $result = $this->petService->getPet($petId);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error getting pet: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(404);
        }
    }
    
    public function listPets(Request $request, Response $response): Response {
        try {
            $queryParams = $request->getQueryParams();
            $filters = [];
            
            // Handle search filters
            $validFilters = ['species', 'breed', 'age_min', 'age_max', 'gender', 'shelter_id', 'traits'];
            foreach ($validFilters as $filter) {
                if (isset($queryParams[$filter])) {
                    if ($filter === 'traits') {
                        // Handle array of traits
                        $filters[$filter] = explode(',', $queryParams[$filter]);
                    } else {
                        $filters[$filter] = $queryParams[$filter];
                    }
                }
            }
            
            $result = $this->petService->listPets($filters);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error listing pets: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function updatePet(Request $request, Response $response, array $args): Response {
        try {
            $petId = (int) $args['id'];
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $body = (string) $request->getBody();
                $data = json_decode($body, true);
                
                if (json_last_error() !== JSON_ERROR_NONE) {
                    throw new \RuntimeException('Invalid JSON data provided');
                }
            }
            
            $result = $this->petService->updatePet($petId, $data);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error updating pet: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function deletePet(Request $request, Response $response, array $args): Response {
        try {
            $petId = (int) $args['id'];
            $this->petService->deletePet($petId);
            
            return $response->withStatus(204);
        } catch (\Exception $e) {
            error_log('Error deleting pet: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function createTrait(Request $request, Response $response): Response {
        try {
            $data = $request->getParsedBody();
            
            if (!is_array($data) || !isset($data['trait_name'])) {
                throw new \RuntimeException('trait_name is required');
            }
            
            $result = $this->petService->addTrait($data['trait_name']);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(201);
        } catch (\Exception $e) {
            error_log('Error creating trait: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function listTraits(Request $request, Response $response): Response {
        try {
            $result = $this->petService->listTraits();
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error listing traits: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(500);
        }
    }
}
=== ./backend/src/api/QuizController.php ===
<?php
namespace PawPath\api;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use PawPath\services\QuizService;
use PawPath\models\StartingQuiz;

class QuizController {
    private QuizService $quizService;
    private StartingQuiz $startingQuiz;
    
    public function __construct() {
        $this->quizService = new QuizService();
        $this->startingQuiz = new StartingQuiz();
    }
    
    /**
     * Initialize a new quiz and return questions
     */
    public function startQuiz(Request $request, Response $response): Response {
        try {
            $questions = $this->quizService->getQuizQuestions();
            
            $response->getBody()->write(json_encode([
                'success' => true,
                'data' => [
                    'questions' => $questions,
                    'total_sections' => count($questions['sections']),
                    'estimated_time' => '5-10 minutes'
                ]
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(200);
        } catch (\Exception $e) {
            $response->getBody()->write(json_encode([
                'success' => false,
                'error' => 'Failed to initialize quiz',
                'message' => $e->getMessage()
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(500);
        }
    }
    
    /**
     * Submit quiz answers and get recommendations
     */
    public function submitQuiz(Request $request, Response $response): Response {
        try {
            $userId = $request->getAttribute('user_id');
            $data = json_decode((string)$request->getBody(), true);
            
            if (json_last_error() !== JSON_ERROR_NONE) {
                throw new \InvalidArgumentException('Invalid JSON data: ' . json_last_error_msg());
            }
            
            if (empty($data['answers'])) {
                throw new \InvalidArgumentException('Quiz answers are required');
            }
            
            // Process quiz and get recommendations
            $result = $this->quizService->processQuiz($userId, $data['answers']);
            
            $response->getBody()->write(json_encode([
                'success' => true,
                'data' => [
                    'quiz_id' => $result['quiz_id'],
                    'recommendations' => [
                        'species' => $result['recommendations']['recommended_species'],
                        'breed' => $result['recommendations']['recommended_breed'],
                        'traits' => $result['recommendations']['trait_preferences']
                    ],
                    'confidence_score' => $result['confidence_score'],
                    'matching_pets' => $result['matching_pets']
                ]
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(200);
        } catch (\InvalidArgumentException $e) {
            $response->getBody()->write(json_encode([
                'success' => false,
                'error' => 'Invalid quiz submission',
                'message' => $e->getMessage()
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(400);
        } catch (\Exception $e) {
            // Add error logging
            error_log("Quiz submission error: " . $e->getMessage());
            error_log("Stack trace: " . $e->getTraceAsString());
            $response->getBody()->write(json_encode([
                'success' => false,
                'error' => 'Failed to process quiz',
                'message' => $e->getMessage()
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(500);
        }
    }
    
    /**
     * Get quiz history for a user
     */
    public function getQuizHistory(Request $request, Response $response): Response {
        try {
            $userId = $request->getAttribute('user_id');
            $history = $this->startingQuiz->findByUser($userId);
            
            // Process history to include more readable data
            $processedHistory = array_map(function($entry) {
                return [
                    'quiz_id' => $entry['quiz_id'],
                    'date_taken' => $entry['quiz_date'],
                    'recommendations' => [
                        'species' => $entry['recommended_species'],
                        'breed' => $entry['recommended_breed'],
                        'traits' => json_decode($entry['trait_preferences'] ?? '{}', true)
                    ]
                ];
            }, $history);
            
            $response->getBody()->write(json_encode([
                'success' => true,
                'data' => [
                    'history' => $processedHistory,
                    'total_quizzes' => count($history)
                ]
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(200);
        } catch (\Exception $e) {
            $response->getBody()->write(json_encode([
                'success' => false,
                'error' => 'Failed to retrieve quiz history',
                'message' => $e->getMessage()
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(500);
        }
    }
    
    /**
     * Get specific quiz result
     */
    public function getQuizResult(Request $request, Response $response, array $args): Response {
        try {
            $quizId = (int) $args['id'];
            $userId = $request->getAttribute('user_id');
            
            // Get quiz and verify it belongs to the user
            $quiz = $this->startingQuiz->findById($quizId);
            
            if (!$quiz) {
                throw new \InvalidArgumentException('Quiz not found');
            }
            
            if ($quiz['user_id'] !== $userId) {
                throw new \InvalidArgumentException('Unauthorized access to quiz result');
            }
            
            $response->getBody()->write(json_encode([
                'success' => true,
                'data' => [
                    'quiz_id' => $quiz['quiz_id'],
                    'date_taken' => $quiz['quiz_date'],
                    'recommendations' => [
                        'species' => $quiz['recommended_species'],
                        'breed' => $quiz['recommended_breed'],
                        'traits' => json_decode($quiz['trait_preferences'] ?? '{}', true)
                    ]
                ]
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(200);
        } catch (\InvalidArgumentException $e) {
            $response->getBody()->write(json_encode([
                'success' => false,
                'error' => 'Invalid quiz request',
                'message' => $e->getMessage()
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(400);
        } catch (\Exception $e) {
            $response->getBody()->write(json_encode([
                'success' => false,
                'error' => 'Failed to retrieve quiz result',
                'message' => $e->getMessage()
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(500);
        }
    }
}
=== ./backend/src/api/ShelterController.php ===
<?php
// backend/src/api/ShelterController.php

namespace PawPath\api;

use PawPath\services\ShelterService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

class ShelterController {
    private ShelterService $shelterService;
    
    public function __construct() {
        $this->shelterService = new ShelterService();
    }
    
    public function createShelter(Request $request, Response $response): Response {
        try {
            $data = $request->getParsedBody();
            error_log('Creating shelter with data: ' . print_r($data, true));
            
            if (!is_array($data)) {
                $body = (string) $request->getBody();
                $data = json_decode($body, true);
                
                if (json_last_error() !== JSON_ERROR_NONE) {
                    throw new \RuntimeException('Invalid JSON data provided');
                }
            }
            
            $result = $this->shelterService->createShelter($data);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(201);
        } catch (\Exception $e) {
            error_log('Error creating shelter: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function getShelter(Request $request, Response $response, array $args): Response {
        try {
            $shelterId = (int) $args['id'];
            $result = $this->shelterService->getShelter($shelterId);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error getting shelter: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(404);
        }
    }
    
    public function listShelters(Request $request, Response $response): Response {
        try {
            $queryParams = $request->getQueryParams();
            $filters = [];
            
            // Handle search parameter
            if (!empty($queryParams['search'])) {
                $filters['search'] = $queryParams['search'];
            }
            
            // Handle no-kill filter
            if (isset($queryParams['is_no_kill'])) {
                $filters['is_no_kill'] = (bool) $queryParams['is_no_kill'];
            }
            
            $result = $this->shelterService->listShelters($filters);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error listing shelters: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(500);
        }
    }
    
    public function updateShelter(Request $request, Response $response, array $args): Response {
        try {
            $shelterId = (int) $args['id'];
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $body = (string) $request->getBody();
                $data = json_decode($body, true);
                
                if (json_last_error() !== JSON_ERROR_NONE) {
                    throw new \RuntimeException('Invalid JSON data provided');
                }
            }
            
            $result = $this->shelterService->updateShelter($shelterId, $data);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error updating shelter: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function deleteShelter(Request $request, Response $response, array $args): Response {
        try {
            $shelterId = (int) $args['id'];
            $this->shelterService->deleteShelter($shelterId);
            
            return $response->withStatus(204);
        } catch (\Exception $e) {
            error_log('Error deleting shelter: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
}
=== ./backend/src/api/AdoptionController.php ===
<?php
// backend/src/api/AdoptionController.php

namespace PawPath\api;

use PawPath\services\AdoptionService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

class AdoptionController {
    private AdoptionService $adoptionService;
    
    public function __construct() {
        $this->adoptionService = new AdoptionService();
    }
    
    public function submitApplication(Request $request, Response $response): Response {
        try {
            $userId = $request->getAttribute('user_id'); // From JWT token
            $data = $request->getParsedBody();
            
            if (!isset($data['pet_id'])) {
                throw new \RuntimeException('pet_id is required');
            }
            
            $result = $this->adoptionService->createApplication(
                $userId,
                (int) $data['pet_id']
            );
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(201);
        } catch (\Exception $e) {
            error_log('Error submitting adoption application: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function getUserApplications(Request $request, Response $response): Response {
        try {
            $userId = $request->getAttribute('user_id'); // From JWT token
            $result = $this->adoptionService->getUserApplications($userId);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error getting user applications: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function getShelterApplications(Request $request, Response $response, array $args): Response {
        try {
            $shelterId = (int) $args['shelter_id'];
            $result = $this->adoptionService->getShelterApplications($shelterId);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error getting shelter applications: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function getApplication(Request $request, Response $response, array $args): Response {
        try {
            $applicationId = (int) $args['id'];
            $result = $this->adoptionService->getApplication($applicationId);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error getting application: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(404);
        }
    }
    
    public function updateApplicationStatus(Request $request, Response $response, array $args): Response {
        try {
            $applicationId = (int) $args['id'];
            $data = $request->getParsedBody();
            
            if (!isset($data['status'])) {
                throw new \RuntimeException('status is required');
            }
            
            $result = $this->adoptionService->updateApplicationStatus(
                $applicationId,
                $data['status']
            );
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error updating application status: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
    
    public function getPetApplications(Request $request, Response $response, array $args): Response {
        try {
            $petId = (int) $args['pet_id'];
            $result = $this->adoptionService->getPetApplications($petId);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } catch (\Exception $e) {
            error_log('Error getting pet applications: ' . $e->getMessage());
            
            $response->getBody()->write(json_encode([
                'error' => $e->getMessage()
            ]));
            return $response->withHeader('Content-Type', 'application/json')
                           ->withStatus(400);
        }
    }
}
=== ./backend/src/api/AuthController.php ===
<?php
// backend/src/api/AuthController.php

namespace PawPath\api;

use PawPath\services\AuthService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

class AuthController {
    private AuthService $authService;
    
    public function __construct() {
        $this->authService = new AuthService();
    }
    
    public function register(Request $request, Response $response): Response {
        try {
            $data = $request->getParsedBody();
            error_log('Received registration data: ' . print_r($data, true));
            
            if (!is_array($data)) {
                $body = (string) $request->getBody();
                $data = json_decode($body, true);
                error_log('Manually parsed JSON data: ' . print_r($data, true));
                
                if (json_last_error() !== JSON_ERROR_NONE) {
                    throw new \RuntimeException('Invalid JSON data provided');
                }
            }
            
            if (empty($data)) {
                throw new \RuntimeException('No data provided');
            }
            
            $result = $this->authService->register($data);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json')->withStatus(201);
            
        } catch (\Exception $e) {
            error_log('Registration error: ' . $e->getMessage());
            
            $errorResponse = [
                'error' => $e->getMessage()
            ];
            
            $response->getBody()->write(json_encode($errorResponse));
            return $response->withHeader('Content-Type', 'application/json')->withStatus(400);
        }
    }
    
    public function login(Request $request, Response $response): Response {
        try {
            $data = $request->getParsedBody();
            error_log('Received login data: ' . print_r($data, true));
            
            if (!is_array($data)) {
                $body = (string) $request->getBody();
                $data = json_decode($body, true);
                error_log('Manually parsed JSON data: ' . print_r($data, true));
                
                if (json_last_error() !== JSON_ERROR_NONE) {
                    throw new \RuntimeException('Invalid JSON data provided');
                }
            }
            
            if (empty($data)) {
                throw new \RuntimeException('No data provided');
            }
            
            $result = $this->authService->login($data);
            
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
            
        } catch (\Exception $e) {
            error_log('Login error: ' . $e->getMessage());
            
            $errorResponse = [
                'error' => $e->getMessage()
            ];
            
            $response->getBody()->write(json_encode($errorResponse));
            return $response->withHeader('Content-Type', 'application/json')->withStatus(401);
        }
    }
}
=== ./backend/src/api/README.md ===
# API Directory
Contains all API endpoint controllers for:
- User Management
- Pet Management
- Shelter Management
- Adoption Applications
- Blog Posts
- Quiz System
- Product/Affiliate Management
=== ./backend/src/utils/README.md ===
# Utils Directory
Helper functions and utilities for:
- Data Validation
- Error Handling
- Authentication
- File Upload
- Email Services
=== ./backend/src/models/Pet.php ===
<?php
namespace PawPath\models;

use PDO;
use PDOException;
use PawPath\config\database\DatabaseConfig;

class Pet {
    private PDO $db;
    private static array $validSpecies = ['Dog', 'Cat', 'Bird', 'Rabbit', 'Other'];

    private function validatePetData(array $data): void {
        $requiredFields = ['name', 'species', 'shelter_id'];
        foreach ($requiredFields as $field) {
            if (empty($data[$field])) {
                throw new \InvalidArgumentException("Missing required field: $field");
            }
        }
        
        if (!in_array(ucfirst(strtolower($data['species'])), self::$validSpecies)) {
            throw new \InvalidArgumentException("Invalid species. Must be one of: " . implode(', ', self::$validSpecies));
        }
    }
 
    public function __construct() {
        $this->db = DatabaseConfig::getConnection();
    }
    
    public function findAll(array $filters = []): array {
        try {
            $query = "
                SELECT p.*, s.name as shelter_name 
                FROM Pet p
                LEFT JOIN Shelter s ON p.shelter_id = s.shelter_id
                WHERE 1=1
            ";
            $params = [];
            
            if (isset($filters['species'])) {
                $query .= " AND p.species = ?";
                $params[] = $filters['species'];
            }
            
            if (isset($filters['shelter_id'])) {
                $query .= " AND p.shelter_id = ?";
                $params[] = $filters['shelter_id'];
            }

            if (isset($filters['breed'])) {
                $query .= " AND p.breed LIKE ?";
                $params[] = '%' . $filters['breed'] . '%';
            }

            if (isset($filters['age_min'])) {
                $query .= " AND p.age >= ?";
                $params[] = $filters['age_min'];
            }

            if (isset($filters['age_max'])) {
                $query .= " AND p.age <= ?";
                $params[] = $filters['age_max'];
            }

            if (isset($filters['gender'])) {
                $query .= " AND p.gender = ?";
                $params[] = $filters['gender'];
            }
            
            $stmt = $this->db->prepare($query);
            $stmt->execute($params);
            $pets = $stmt->fetchAll();

            // Get traits for each pet
            foreach ($pets as &$pet) {
                $stmt = $this->db->prepare("
                    SELECT t.trait_id, t.trait_name, tc.name as category_name
                    FROM Pet_Trait_Relation ptr
                    JOIN Pet_Trait t ON ptr.trait_id = t.trait_id
                    LEFT JOIN Trait_Category tc ON t.category_id = tc.category_id
                    WHERE ptr.pet_id = ?
                ");
                $stmt->execute([$pet['pet_id']]);
                $pet['traits'] = $stmt->fetchAll();
            }
            
            return $pets;
        } catch (PDOException $e) {
            error_log("Error finding pets: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findById(int $id): ?array {
        try {
            $stmt = $this->db->prepare("
                SELECT p.*, s.name as shelter_name
                FROM Pet p
                LEFT JOIN Shelter s ON p.shelter_id = s.shelter_id
                WHERE p.pet_id = ?
            ");
            $stmt->execute([$id]);
            $pet = $stmt->fetch();
            
            if (!$pet) {
                return null;
            }
            
            // Get pet traits with categories
            $stmt = $this->db->prepare("
                SELECT t.trait_id, t.trait_name, t.value_type, t.possible_values,
                       tc.name as category_name, tc.description as category_description
                FROM Pet_Trait_Relation ptr
                JOIN Pet_Trait t ON ptr.trait_id = t.trait_id
                LEFT JOIN Trait_Category tc ON t.category_id = tc.category_id
                WHERE ptr.pet_id = ?
            ");
            $stmt->execute([$id]);
            $pet['traits'] = $stmt->fetchAll();
            
            return $pet;
        } catch (PDOException $e) {
            error_log("Error finding pet by ID: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function create(array $data): int {
        try {
            $this->db->beginTransaction();
            
            error_log("Starting pet creation with data: " . print_r($data, true));
            
            // Validate required fields
            $this->validatePetData($data);
            
            $stmt = $this->db->prepare("
                INSERT INTO Pet (name, species, breed, age, gender, description, shelter_id)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ");
            
            $result = $stmt->execute([
                $data['name'],
                $data['species'],
                $data['breed'] ?? null,
                $data['age'] ?? null,
                $data['gender'] ?? null,
                $data['description'] ?? null,
                $data['shelter_id']
            ]);
            
            if (!$result) {
                error_log("SQL Error: " . print_r($stmt->errorInfo(), true));
                throw new \PDOException("Failed to insert pet");
            }
            
            $petId = (int) $this->db->lastInsertId();
            error_log("Created pet with ID: $petId");
            
            // Add traits if provided
            if (!empty($data['traits']) && is_array($data['traits'])) {
                $this->addTraitsToPet($petId, $data['traits']);
            }
            
            $this->db->commit();
            return $petId;
        } catch (\Exception $e) {
            $this->db->rollBack();
            error_log("Error in Pet::create: " . $e->getMessage() . "\n" . $e->getTraceAsString());
            throw $e;
        }
    }
    
    public function update(int $id, array $data): bool {
        try {
            $this->db->beginTransaction();
            
            $fields = [];
            $params = [];
            
            foreach ($data as $key => $value) {
                if (in_array($key, ['name', 'species', 'breed', 'age', 'gender', 'description', 'shelter_id'])) {
                    $fields[] = "$key = ?";
                    $params[] = $value;
                }
            }
            
            if (!empty($fields)) {
                $params[] = $id;
                $query = "UPDATE Pet SET " . implode(', ', $fields) . " WHERE pet_id = ?";
                
                $stmt = $this->db->prepare($query);
                $stmt->execute($params);
            }
            
            // Update traits if provided
            if (isset($data['traits']) && is_array($data['traits'])) {
                // Remove existing traits
                $stmt = $this->db->prepare("DELETE FROM Pet_Trait_Relation WHERE pet_id = ?");
                $stmt->execute([$id]);
                
                // Add new traits
                $this->addTraitsToPet($id, $data['traits']);
            }
            
            $this->db->commit();
            return true;
        } catch (PDOException $e) {
            $this->db->rollBack();
            error_log("Error updating pet: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function delete(int $id): bool {
        try {
            $this->db->beginTransaction();
            
            // Delete trait relations first
            $stmt = $this->db->prepare("DELETE FROM Pet_Trait_Relation WHERE pet_id = ?");
            $stmt->execute([$id]);
            
            // Delete pet
            $stmt = $this->db->prepare("DELETE FROM Pet WHERE pet_id = ?");
            $result = $stmt->execute([$id]);
            
            $this->db->commit();
            return $result;
        } catch (PDOException $e) {
            $this->db->rollBack();
            error_log("Error deleting pet: " . $e->getMessage());
            throw $e;
        }
    }

    public function findAllWithTraits(array $filters = []): array {
        try {
            error_log("Finding pets with filters: " . json_encode($filters, JSON_PRETTY_PRINT));
            
            // First, let's verify what traits exist in the database
            $stmt = $this->db->query("
                SELECT t.trait_id, t.trait_name, tc.name as category 
                FROM Pet_Trait t 
                LEFT JOIN Trait_Category tc ON t.category_id = tc.category_id
            ");
            error_log("Available traits: " . json_encode($stmt->fetchAll(), JSON_PRETTY_PRINT));
            
            // Then verify what pets and their traits exist
            $stmt = $this->db->query("
                SELECT p.pet_id, p.name, t.trait_name 
                FROM Pet p 
                LEFT JOIN Pet_Trait_Relation ptr ON p.pet_id = ptr.pet_id 
                LEFT JOIN Pet_Trait t ON ptr.trait_id = t.trait_id
            ");
            error_log("Existing pets and traits: " . json_encode($stmt->fetchAll(), JSON_PRETTY_PRINT));
            
            $query = "
                SELECT 
                    p.*,
                    s.name as shelter_name,
                    GROUP_CONCAT(DISTINCT t.trait_name) as trait_names,
                    COUNT(DISTINCT CASE 
                        WHEN t.trait_name IN (" . $this->buildTraitNameList($filters) . ") 
                        THEN t.trait_id 
                    END) as matching_trait_count
                FROM Pet p
                LEFT JOIN Shelter s ON p.shelter_id = s.shelter_id
                LEFT JOIN Pet_Trait_Relation ptr ON p.pet_id = ptr.pet_id
                LEFT JOIN Pet_Trait t ON ptr.trait_id = t.trait_id
                WHERE 1=1
            ";
            
            $params = [];
            
            if (!empty($filters['species'])) {
                $query .= " AND p.species = ?";
                $params[] = $filters['species'];
            }
            
            $query .= " GROUP BY p.pet_id";
            
            if (!empty($filters['traits'])) {
                $query .= " HAVING matching_trait_count > 0";
            }
            
            $query .= " ORDER BY matching_trait_count DESC, p.name";
            
            error_log("Executing query: " . $query);
            error_log("With params: " . json_encode($params));
            
            $stmt = $this->db->prepare($query);
            $stmt->execute($params);
            $pets = $stmt->fetchAll();
            
            error_log("Found pets: " . json_encode($pets, JSON_PRETTY_PRINT));
            
            foreach ($pets as &$pet) {
                $stmt = $this->db->prepare("
                    SELECT t.trait_name, tc.name as category
                    FROM Pet_Trait_Relation ptr
                    JOIN Pet_Trait t ON ptr.trait_id = t.trait_id
                    LEFT JOIN Trait_Category tc ON t.category_id = tc.category_id
                    WHERE ptr.pet_id = ?
                ");
                $stmt->execute([$pet['pet_id']]);
                $traits = $stmt->fetchAll();
                
                $pet['traits'] = [];
                foreach ($traits as $trait) {
                    $category = $trait['category'] ?? 'Uncategorized';
                    if (!isset($pet['traits'][$category])) {
                        $pet['traits'][$category] = [];
                    }
                    $pet['traits'][$category][] = $trait['trait_name'];
                }
            }
            
            return $pets;
        } catch (PDOException $e) {
            error_log("Error finding pets with traits: " . $e->getMessage());
            throw $e;
        }
    }

    private function addTraitsToPet(int $petId, array $traitIds): void {
        // First verify all traits exist
        $placeholders = str_repeat('?,', count($traitIds) - 1) . '?';
        $stmt = $this->db->prepare("
            SELECT trait_id FROM Pet_Trait 
            WHERE trait_id IN ($placeholders)
        ");
        $stmt->execute($traitIds);
        $validTraits = $stmt->fetchAll(PDO::FETCH_COLUMN);
        
        error_log("Valid traits found for pet $petId: " . implode(', ', $validTraits));
        
        if (count($validTraits) !== count($traitIds)) {
            throw new \InvalidArgumentException("Some trait IDs are invalid");
        }
        
        // Insert valid traits
        $stmt = $this->db->prepare("
            INSERT INTO Pet_Trait_Relation (pet_id, trait_id)
            VALUES (?, ?)
        ");
        
        foreach ($validTraits as $traitId) {
            $stmt->execute([$petId, $traitId]);
            error_log("Added trait $traitId to pet $petId");
        }
    }

    private function buildTraitNameList(array $filters): string {
        if (empty($filters['traits'])) {
            return "''";
        }
        
        $traitNames = array_map(function($trait) {
            return $this->db->quote($trait['trait']);
        }, $filters['traits']);
        
        // Add debugging
        error_log("Building trait list from: " . json_encode($filters['traits']));
        error_log("Generated trait list: " . implode(',', $traitNames));
        
        return implode(',', $traitNames);
    }

    private function processTraits(?string $traitsJson): array {
        if (empty($traitsJson)) {
            return [];
        }
        
        $formatted = [];
        $traits = array_filter(explode('},{', trim($traitsJson, '[]')));
        
        foreach ($traits as $trait) {
            if (!str_ends_with($trait, '}')) $trait .= '}';
            if (!str_starts_with($trait, '{')) $trait = '{' . $trait;
            
            $traitData = json_decode($trait, true);
            if ($traitData) {
                $category = $traitData['category'];
                if (!isset($formatted[$category])) {
                    $formatted[$category] = [];
                }
                $formatted[$category][] = $traitData['name'];
            }
        }
        
        return $formatted;
    }
}
=== ./backend/src/models/Shelter.php ===
<?php
// backend/src/models/Shelter.php

namespace PawPath\models;

use PDO;
use PDOException;
use PawPath\config\database\DatabaseConfig;

class Shelter {
    private PDO $db;
    
    public function __construct() {
        $this->db = DatabaseConfig::getConnection();
    }
    
    public function create(array $data): int {
        try {
            error_log("Creating new shelter: " . $data['name']);
            
            $stmt = $this->db->prepare("
                INSERT INTO Shelter (name, address, phone, email, is_no_kill)
                VALUES (?, ?, ?, ?, ?)
            ");
            
            $success = $stmt->execute([
                $data['name'],
                $data['address'],
                $data['phone'],
                $data['email'],
                $data['is_no_kill'] ?? false
            ]);
            
            if (!$success) {
                error_log("Failed to create shelter: " . print_r($stmt->errorInfo(), true));
                throw new PDOException("Failed to create shelter");
            }
            
            $shelterId = (int) $this->db->lastInsertId();
            error_log("Created shelter with ID: " . $shelterId);
            
            return $shelterId;
        } catch (PDOException $e) {
            error_log("Error creating shelter: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findById(int $id): ?array {
        try {
            $stmt = $this->db->prepare("
                SELECT shelter_id, name, address, phone, email, is_no_kill
                FROM Shelter
                WHERE shelter_id = ?
            ");
            
            $stmt->execute([$id]);
            $shelter = $stmt->fetch();
            
            return $shelter ?: null;
        } catch (PDOException $e) {
            error_log("Error finding shelter: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findAll(array $filters = []): array {
        try {
            $query = "SELECT shelter_id, name, address, phone, email, is_no_kill FROM Shelter WHERE 1=1";
            $params = [];
            
            // Add filter for no-kill shelters
            if (isset($filters['is_no_kill'])) {
                $query .= " AND is_no_kill = ?";
                $params[] = $filters['is_no_kill'];
            }
            
            // Add search by name
            if (!empty($filters['search'])) {
                $query .= " AND name LIKE ?";
                $params[] = '%' . $filters['search'] . '%';
            }
            
            $stmt = $this->db->prepare($query);
            $stmt->execute($params);
            
            return $stmt->fetchAll();
        } catch (PDOException $e) {
            error_log("Error finding shelters: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function update(int $id, array $data): bool {
        try {
            $fields = [];
            $params = [];
            
            // Build update fields dynamically
            foreach (['name', 'address', 'phone', 'email', 'is_no_kill'] as $field) {
                if (isset($data[$field])) {
                    $fields[] = "$field = ?";
                    $params[] = $data[$field];
                }
            }
            
            if (empty($fields)) {
                return false;
            }
            
            $params[] = $id;
            $query = "UPDATE Shelter SET " . implode(', ', $fields) . " WHERE shelter_id = ?";
            
            $stmt = $this->db->prepare($query);
            return $stmt->execute($params);
        } catch (PDOException $e) {
            error_log("Error updating shelter: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function delete(int $id): bool {
        try {
            // First check if there are any pets associated with this shelter
            $stmt = $this->db->prepare("SELECT COUNT(*) FROM Pet WHERE shelter_id = ?");
            $stmt->execute([$id]);
            $petCount = $stmt->fetchColumn();
            
            if ($petCount > 0) {
                throw new \RuntimeException("Cannot delete shelter with existing pets");
            }
            
            $stmt = $this->db->prepare("DELETE FROM Shelter WHERE shelter_id = ?");
            return $stmt->execute([$id]);
        } catch (PDOException $e) {
            error_log("Error deleting shelter: " . $e->getMessage());
            throw $e;
        }
    }
}
=== ./backend/src/models/User.php ===
<?php
// backend/src/models/User.php

namespace PawPath\models;

use PDO;
use PDOException;
use PawPath\config\database\DatabaseConfig;

class User {
    private PDO $db;
    
    public function __construct() {
        $this->db = DatabaseConfig::getConnection();
    }
    
    public function create(array $data): int {
        try {
            error_log("Attempting to create user with username: " . $data['username']);
            
            $stmt = $this->db->prepare("
                INSERT INTO User (username, email, password_hash, registration_date)
                VALUES (?, ?, ?, CURDATE())
            ");
            
            $success = $stmt->execute([
                $data['username'],
                $data['email'],
                password_hash($data['password'], PASSWORD_DEFAULT)
            ]);
            
            if (!$success) {
                error_log("Failed to execute user creation query");
                error_log(print_r($stmt->errorInfo(), true));
                throw new PDOException("Failed to create user");
            }
            
            $userId = (int) $this->db->lastInsertId();
            error_log("Successfully created user with ID: " . $userId);
            
            return $userId;
        } catch (PDOException $e) {
            error_log("Error creating user: " . $e->getMessage());
            throw $e;
        }
    }

    public function findById(int $id): ?array {
        try {
            error_log("Looking up user with ID: " . $id);
            
            $stmt = $this->db->prepare("
                SELECT user_id, username, email, registration_date 
                FROM User 
                WHERE user_id = ?
            ");
            
            $stmt->execute([$id]);
            $user = $stmt->fetch();
            
            if ($user === false) {
                error_log("No user found with ID: " . $id);
                return null;
            }
            
            error_log("Found user: " . print_r($user, true));
            return $user;
        } catch (PDOException $e) {
            error_log("Error finding user: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findByEmail(string $email): ?array {
        try {
            $stmt = $this->db->prepare("
                SELECT user_id, username, email, password_hash, registration_date 
                FROM User 
                WHERE email = ?
            ");
            
            $stmt->execute([$email]);
            $user = $stmt->fetch();
            
            return $user === false ? null : $user;
        } catch (PDOException $e) {
            error_log("Error finding user by email: " . $e->getMessage());
            throw $e;
        }
    }
}
=== ./backend/src/models/AdoptionApplication.php ===
<?php
// backend/src/models/AdoptionApplication.php

namespace PawPath\models;

use PDO;
use PDOException;
use PawPath\config\database\DatabaseConfig;

class AdoptionApplication {
    private PDO $db;
    
    const STATUS_PENDING = 'pending';
    const STATUS_UNDER_REVIEW = 'under_review';
    const STATUS_APPROVED = 'approved';
    const STATUS_REJECTED = 'rejected';
    const STATUS_WITHDRAWN = 'withdrawn';
    
    public function __construct() {
        $this->db = DatabaseConfig::getConnection();
    }
    
    public function create(array $data): int {
        try {
            $stmt = $this->db->prepare("
                INSERT INTO Adoption_Application (
                    user_id,
                    pet_id,
                    application_date,
                    status
                ) VALUES (?, ?, CURDATE(), ?)
            ");
            
            $stmt->execute([
                $data['user_id'],
                $data['pet_id'],
                self::STATUS_PENDING
            ]);
            
            $applicationId = (int) $this->db->lastInsertId();
            error_log("Created adoption application with ID: " . $applicationId);
            
            return $applicationId;
        } catch (PDOException $e) {
            error_log("Error creating adoption application: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findById(int $id): ?array {
        try {
            $stmt = $this->db->prepare("
                SELECT 
                    aa.*,
                    u.username as user_name,
                    p.name as pet_name,
                    p.species as pet_species,
                    p.breed as pet_breed,
                    s.name as shelter_name
                FROM Adoption_Application aa
                JOIN User u ON aa.user_id = u.user_id
                JOIN Pet p ON aa.pet_id = p.pet_id
                JOIN Shelter s ON p.shelter_id = s.shelter_id
                WHERE aa.application_id = ?
            ");
            
            $stmt->execute([$id]);
            $result = $stmt->fetch();
            
            return $result ?: null;
        } catch (PDOException $e) {
            error_log("Error finding adoption application: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findByUser(int $userId): array {
        try {
            $stmt = $this->db->prepare("
                SELECT 
                    aa.*,
                    u.username as user_name,
                    p.name as pet_name,
                    p.species as pet_species,
                    p.breed as pet_breed,
                    s.name as shelter_name
                FROM Adoption_Application aa
                JOIN User u ON aa.user_id = u.user_id
                JOIN Pet p ON aa.pet_id = p.pet_id
                JOIN Shelter s ON p.shelter_id = s.shelter_id
                WHERE aa.user_id = ?
                ORDER BY aa.application_date DESC
            ");
            
            $stmt->execute([$userId]);
            return $stmt->fetchAll();
        } catch (PDOException $e) {
            error_log("Error finding user's adoption applications: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findByShelter(int $shelterId): array {
        try {
            $stmt = $this->db->prepare("
                SELECT 
                    aa.*,
                    u.username as user_name,
                    p.name as pet_name,
                    p.species as pet_species,
                    p.breed as pet_breed,
                    s.name as shelter_name
                FROM Adoption_Application aa
                JOIN User u ON aa.user_id = u.user_id
                JOIN Pet p ON aa.pet_id = p.pet_id
                JOIN Shelter s ON p.shelter_id = s.shelter_id
                WHERE p.shelter_id = ?
                ORDER BY aa.application_date DESC
            ");
            
            $stmt->execute([$shelterId]);
            return $stmt->fetchAll();
        } catch (PDOException $e) {
            error_log("Error finding shelter's adoption applications: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function updateStatus(int $id, string $status): bool {
        try {
            $stmt = $this->db->prepare("
                UPDATE Adoption_Application
                SET status = ?
                WHERE application_id = ?
            ");
            
            return $stmt->execute([$status, $id]);
        } catch (PDOException $e) {
            error_log("Error updating adoption application status: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findByPet(int $petId): array {
        try {
            $stmt = $this->db->prepare("
                SELECT 
                    aa.*,
                    u.username as user_name,
                    p.name as pet_name,
                    p.species as pet_species,
                    p.breed as pet_breed,
                    s.name as shelter_name
                FROM Adoption_Application aa
                JOIN User u ON aa.user_id = u.user_id
                JOIN Pet p ON aa.pet_id = p.pet_id
                JOIN Shelter s ON p.shelter_id = s.shelter_id
                WHERE aa.pet_id = ?
                ORDER BY aa.application_date DESC
            ");
            
            $stmt->execute([$petId]);
            return $stmt->fetchAll();
        } catch (PDOException $e) {
            error_log("Error finding pet's adoption applications: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function hasUserAppliedForPet(int $userId, int $petId): bool {
        try {
            $stmt = $this->db->prepare("
                SELECT COUNT(*) FROM Adoption_Application
                WHERE user_id = ? AND pet_id = ?
                AND status NOT IN (?, ?)
            ");
            
            $stmt->execute([$userId, $petId, self::STATUS_WITHDRAWN, self::STATUS_REJECTED]);
            return (bool) $stmt->fetchColumn();
        } catch (PDOException $e) {
            error_log("Error checking user's pet application: " . $e->getMessage());
            throw $e;
        }
    }
}
=== ./backend/src/models/QuizResult.php ===
<?php

namespace PawPath\Models;

class QuizResult {
    private PDO $db;
    
    public function __construct() {
        $this->db = DatabaseConfig::getConnection();
    }
    
    public function create(array $data): int {
        $stmt = $this->db->prepare("
            INSERT INTO Quiz_Result (quiz_id, recommended_species, recommended_breed)
            VALUES (?, ?, ?)
        ");
        
        $stmt->execute([
            $data['quiz_id'],
            $data['recommended_species'] ?? null,
            $data['recommended_breed'] ?? null
        ]);
        
        return (int) $this->db->lastInsertId();
    }
    
    public function findByQuizId(int $quizId): ?array {
        $stmt = $this->db->prepare("
            SELECT * FROM Quiz_Result WHERE quiz_id = ?
        ");
        
        $stmt->execute([$quizId]);
        $result = $stmt->fetch();
        return $result !== false ? $result : null;
    }
}
=== ./backend/src/models/PetTrait.php ===
<?php
// backend/src/models/PetTrait.php

namespace PawPath\models;

use PDO;
use PDOException;
use PawPath\config\database\DatabaseConfig;

class PetTrait {
    private PDO $db;
    
    public function __construct() {
        $this->db = DatabaseConfig::getConnection();
    }
    
    public function create(string $traitName): int {
        try {
            $stmt = $this->db->prepare("
                INSERT INTO Pet_Trait (trait_name)
                VALUES (?)
            ");
            
            $stmt->execute([$traitName]);
            return (int) $this->db->lastInsertId();
        } catch (PDOException $e) {
            error_log("Error creating pet trait: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findAll(): array {
        try {
            $stmt = $this->db->prepare("
                SELECT trait_id, trait_name
                FROM Pet_Trait
                ORDER BY trait_name
            ");
            
            $stmt->execute();
            return $stmt->fetchAll();
        } catch (PDOException $e) {
            error_log("Error finding pet traits: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findById(int $id): ?array {
        try {
            $stmt = $this->db->prepare("
                SELECT trait_id, trait_name
                FROM Pet_Trait
                WHERE trait_id = ?
            ");
            
            $stmt->execute([$id]);
            $result = $stmt->fetch();
            
            return $result ?: null;
        } catch (PDOException $e) {
            error_log("Error finding pet trait: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function update(int $id, string $traitName): bool {
        try {
            $stmt = $this->db->prepare("
                UPDATE Pet_Trait
                SET trait_name = ?
                WHERE trait_id = ?
            ");
            
            return $stmt->execute([$traitName, $id]);
        } catch (PDOException $e) {
            error_log("Error updating pet trait: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function delete(int $id): bool {
        try {
            // Check if trait is in use
            $stmt = $this->db->prepare("
                SELECT COUNT(*) FROM Pet_Trait_Relation
                WHERE trait_id = ?
            ");
            $stmt->execute([$id]);
            
            if ($stmt->fetchColumn() > 0) {
                throw new \RuntimeException("Cannot delete trait that is in use");
            }
            
            $stmt = $this->db->prepare("
                DELETE FROM Pet_Trait
                WHERE trait_id = ?
            ");
            
            return $stmt->execute([$id]);
        } catch (PDOException $e) {
            error_log("Error deleting pet trait: " . $e->getMessage());
            throw $e;
        }
    }
}
=== ./backend/src/models/StartingQuiz.php ===
<?php
// src/models/StartingQuiz.php
namespace PawPath\models;

use PDO;
use PDOException;
use PawPath\config\database\DatabaseConfig;

class StartingQuiz {
    private PDO $db;
    
    public function __construct() {
        $this->db = DatabaseConfig::getConnection();
    }
    
    public function create(int $userId): int {
        try {
            $stmt = $this->db->prepare("
                INSERT INTO Starting_Quiz (user_id, quiz_date)
                VALUES (?, CURRENT_TIMESTAMP)
            ");
            
            $stmt->execute([$userId]);
            return (int) $this->db->lastInsertId();
        } catch (PDOException $e) {
            error_log("Error creating quiz: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findByUser(int $userId): array {
        try {
            $stmt = $this->db->prepare("
                SELECT sq.*, qr.recommended_species, qr.recommended_breed,
                       qr.trait_preferences
                FROM Starting_Quiz sq
                LEFT JOIN Quiz_Result qr ON sq.quiz_id = qr.quiz_id
                WHERE sq.user_id = ?
                ORDER BY sq.quiz_date DESC
            ");
            
            $stmt->execute([$userId]);
            return $stmt->fetchAll();
        } catch (PDOException $e) {
            error_log("Error finding user quizzes: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findById(int $quizId): ?array {
        try {
            $stmt = $this->db->prepare("
                SELECT sq.*, qr.recommended_species, qr.recommended_breed,
                       qr.trait_preferences
                FROM Starting_Quiz sq
                LEFT JOIN Quiz_Result qr ON sq.quiz_id = qr.quiz_id
                WHERE sq.quiz_id = ?
            ");
            
            $stmt->execute([$quizId]);
            $result = $stmt->fetch();
            
            return $result ?: null;
        } catch (PDOException $e) {
            error_log("Error finding quiz: " . $e->getMessage());
            throw $e;
        }
    }
}

// src/models/QuizResult.php
class QuizResult {
    private PDO $db;
    
    public function __construct() {
        $this->db = DatabaseConfig::getConnection();
    }
    
    public function create(array $data): int {
        try {
            $stmt = $this->db->prepare("
                INSERT INTO Quiz_Result (
                    quiz_id, 
                    recommended_species, 
                    recommended_breed,
                    trait_preferences,
                    confidence_score
                ) VALUES (?, ?, ?, ?, ?)
            ");
            
            $stmt->execute([
                $data['quiz_id'],
                $data['recommended_species'],
                $data['recommended_breed'],
                json_encode($data['trait_preferences'] ?? []),
                $data['confidence_score'] ?? 0
            ]);
            
            return (int) $this->db->lastInsertId();
        } catch (PDOException $e) {
            error_log("Error creating quiz result: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function findByQuizId(int $quizId): ?array {
        try {
            $stmt = $this->db->prepare("
                SELECT * FROM Quiz_Result WHERE quiz_id = ?
            ");
            
            $stmt->execute([$quizId]);
            $result = $stmt->fetch();
            
            if ($result && isset($result['trait_preferences'])) {
                $result['trait_preferences'] = json_decode($result['trait_preferences'], true);
            }
            
            return $result ?: null;
        } catch (PDOException $e) {
            error_log("Error finding quiz result: " . $e->getMessage());
            throw $e;
        }
    }
}
=== ./backend/src/models/README.md ===
# Models Directory
Database models matching our schema for:
- User
- Shelter
- Pet
- Adoption_Application
- Blog_Post
- Pet_Trait
- Starting_Quiz
- Quiz_Result
- Product
=== ./backend/src/services/AdoptionService.php ===
<?php
// backend/src/services/AdoptionService.php

namespace PawPath\services;

use PawPath\models\AdoptionApplication;
use PawPath\models\Pet;
use PawPath\models\User;
use RuntimeException;

class AdoptionService {
    private AdoptionApplication $applicationModel;
    private Pet $petModel;
    private User $userModel;
    
    public function __construct() {
        $this->applicationModel = new AdoptionApplication();
        $this->petModel = new Pet();
        $this->userModel = new User();
    }
    
    public function createApplication(int $userId, int $petId): array {
        // Verify user exists
        $user = $this->userModel->findById($userId);
        if (!$user) {
            throw new RuntimeException("User not found");
        }
        
        // Verify pet exists
        $pet = $this->petModel->findById($petId);
        if (!$pet) {
            throw new RuntimeException("Pet not found");
        }
        
        // Check if user has already applied for this pet
        if ($this->applicationModel->hasUserAppliedForPet($userId, $petId)) {
            throw new RuntimeException("You have already applied to adopt this pet");
        }
        
        // Create application
        $applicationId = $this->applicationModel->create([
            'user_id' => $userId,
            'pet_id' => $petId
        ]);
        
        return $this->applicationModel->findById($applicationId);
    }
    
    public function getUserApplications(int $userId): array {
        // Verify user exists
        $user = $this->userModel->findById($userId);
        if (!$user) {
            throw new RuntimeException("User not found");
        }
        
        return $this->applicationModel->findByUser($userId);
    }
    
    public function getShelterApplications(int $shelterId): array {
        return $this->applicationModel->findByShelter($shelterId);
    }
    
    public function getApplication(int $applicationId): ?array {
        $application = $this->applicationModel->findById($applicationId);
        if (!$application) {
            throw new RuntimeException("Application not found");
        }
        return $application;
    }
    
    public function updateApplicationStatus(int $applicationId, string $status): array {
        // Verify application exists
        $application = $this->applicationModel->findById($applicationId);
        if (!$application) {
            throw new RuntimeException("Application not found");
        }
        
        // Validate status
        $validStatuses = [
            AdoptionApplication::STATUS_PENDING,
            AdoptionApplication::STATUS_UNDER_REVIEW,
            AdoptionApplication::STATUS_APPROVED,
            AdoptionApplication::STATUS_REJECTED,
            AdoptionApplication::STATUS_WITHDRAWN
        ];
        
        if (!in_array($status, $validStatuses)) {
            throw new RuntimeException("Invalid application status");
        }
        
        // Update status
        $this->applicationModel->updateStatus($applicationId, $status);
        
        return $this->applicationModel->findById($applicationId);
    }
    
    public function getPetApplications(int $petId): array {
        // Verify pet exists
        $pet = $this->petModel->findById($petId);
        if (!$pet) {
            throw new RuntimeException("Pet not found");
        }
        
        return $this->applicationModel->findByPet($petId);
    }
}
=== ./backend/src/services/ShelterService.php ===
<?php
// backend/src/services/ShelterService.php

namespace PawPath\services;

use PawPath\models\Shelter;
use RuntimeException;

class ShelterService {
    private Shelter $shelterModel;
    
    public function __construct() {
        $this->shelterModel = new Shelter();
    }
    
    public function createShelter(array $data): array {
        // Validate required fields
        $requiredFields = ['name', 'address', 'phone', 'email'];
        foreach ($requiredFields as $field) {
            if (empty($data[$field])) {
                throw new RuntimeException("Missing required field: $field");
            }
        }
        
        // Validate email format
        if (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            throw new RuntimeException("Invalid email format");
        }
        
        // Validate phone number (basic validation)
        if (!preg_match("/^[0-9\-\(\)\/\+\s]*$/", $data['phone'])) {
            throw new RuntimeException("Invalid phone number format");
        }
        
        // Create shelter
        $shelterId = $this->shelterModel->create($data);
        
        // Return the created shelter
        return $this->shelterModel->findById($shelterId);
    }
    
    public function updateShelter(int $id, array $data): array {
        // Verify shelter exists
        $shelter = $this->shelterModel->findById($id);
        if (!$shelter) {
            throw new RuntimeException("Shelter not found");
        }
        
        // Validate email if provided
        if (isset($data['email']) && !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            throw new RuntimeException("Invalid email format");
        }
        
        // Validate phone if provided
        if (isset($data['phone']) && !preg_match("/^[0-9\-\(\)\/\+\s]*$/", $data['phone'])) {
            throw new RuntimeException("Invalid phone number format");
        }
        
        // Update shelter
        $success = $this->shelterModel->update($id, $data);
        if (!$success) {
            throw new RuntimeException("Failed to update shelter");
        }
        
        // Return updated shelter
        return $this->shelterModel->findById($id);
    }
    
    public function deleteShelter(int $id): bool {
        // Verify shelter exists
        $shelter = $this->shelterModel->findById($id);
        if (!$shelter) {
            throw new RuntimeException("Shelter not found");
        }
        
        return $this->shelterModel->delete($id);
    }
    
    public function getShelter(int $id): ?array {
        $shelter = $this->shelterModel->findById($id);
        if (!$shelter) {
            throw new RuntimeException("Shelter not found");
        }
        return $shelter;
    }
    
    public function listShelters(array $filters = []): array {
        return $this->shelterModel->findAll($filters);
    }
}
=== ./backend/src/services/AuthService.php ===
<?php
// backend/src/services/AuthService.php

namespace PawPath\services;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use PawPath\models\User;
use RuntimeException;

class AuthService {
    private User $userModel;
    private string $jwtSecret;
    
    public function __construct() {
        $this->userModel = new User();
        $this->jwtSecret = $_ENV['JWT_SECRET'] ?? throw new RuntimeException('JWT_SECRET not set');
    }
    
    public function register(array $data): array {
        // Validate input
        if (empty($data['username']) || empty($data['email']) || empty($data['password'])) {
            throw new RuntimeException('Missing required fields');
        }
        
        // Check if email already exists
        if ($this->userModel->findByEmail($data['email'])) {
            throw new RuntimeException('Email already registered');
        }
        
        // Create user
        $userId = $this->userModel->create($data);
        
        // Get user data
        $user = $this->userModel->findById($userId);
        
        // Generate token
        return [
            'user' => $user,
            'token' => $this->generateToken($userId)
        ];
    }

    public function login(array $data): array {
        error_log('Login attempt for email: ' . ($data['email'] ?? 'not provided'));
        
        // Validate input
        if (empty($data['email']) || empty($data['password'])) {
            throw new RuntimeException('Email and password are required');
        }
        
        // Find user
        $user = $this->userModel->findByEmail($data['email']);
        
        if (!$user) {
            error_log('User not found for email: ' . $data['email']);
            throw new RuntimeException('Invalid credentials');
        }
        
        // Verify password
        if (!password_verify($data['password'], $user['password_hash'])) {
            error_log('Invalid password for user: ' . $data['email']);
            throw new RuntimeException('Invalid credentials');
        }
        
        // Remove password hash from response
        unset($user['password_hash']);
        
        error_log('Successful login for user: ' . $data['email']);
        
        // Return user data and token
        return [
            'user' => $user,
            'token' => $this->generateToken($user['user_id'])
        ];
    }
    
    private function generateToken(int $userId): string {
        $payload = [
            'user_id' => $userId,
            'iat' => time(),
            'exp' => time() + (24 * 60 * 60) // 24 hours
        ];
        
        return JWT::encode($payload, $this->jwtSecret, 'HS256');
    }

    public function validateToken(string $token): ?array {
        try {
            error_log("Attempting to validate token");
            
            $decoded = JWT::decode(
                $token, 
                new Key($this->jwtSecret, 'HS256')
            );
            
            $payload = (array) $decoded;
            error_log("Token validated successfully for user_id: " . ($payload['user_id'] ?? 'unknown'));
            
            return $payload;
        } catch (\Exception $e) {
            error_log("Token validation failed: " . $e->getMessage());
            return null;
        }
    }
}
=== ./backend/src/services/PetService.php ===
<?php
// backend/src/services/PetService.php

namespace PawPath\services;

use PawPath\models\Pet;
use PawPath\models\PetTrait;
use PawPath\models\Shelter;
use RuntimeException;

class PetService {
    private Pet $petModel;
    private PetTrait $traitModel;
    private Shelter $shelterModel;
    
    public function __construct() {
        $this->petModel = new Pet();
        $this->traitModel = new PetTrait();
        $this->shelterModel = new Shelter();
    }
    
    public function createPet(array $data): array {
        try {
            error_log("Creating pet with data: " . json_encode($data));
            
            // Validate required fields
            $requiredFields = ['name', 'species', 'shelter_id'];
            foreach ($requiredFields as $field) {
                if (empty($data[$field])) {
                    throw new RuntimeException("Missing required field: $field");
                }
            }
            
            // Create pet
            $petId = $this->petModel->create($data);
            error_log("Created pet with ID: $petId");
            
            $pet = $this->petModel->findById($petId);
            if (!$pet) {
                throw new RuntimeException("Failed to retrieve created pet");
            }
            
            return $pet;
        } catch (\Exception $e) {
            error_log("Error in PetService::createPet: " . $e->getMessage());
            throw $e;
        }
    }
    
    public function updatePet(int $id, array $data): array {
        // Verify pet exists
        $pet = $this->petModel->findById($id);
        if (!$pet) {
            throw new RuntimeException("Pet not found");
        }
        
        // Validate species if provided
        if (isset($data['species'])) {
            $validSpecies = ['Dog', 'Cat', 'Bird', 'Rabbit', 'Other'];
            if (!in_array($data['species'], $validSpecies)) {
                throw new RuntimeException("Invalid species");
            }
        }
        
        // Validate age if provided
        if (isset($data['age']) && ($data['age'] < 0 || $data['age'] > 30)) {
            throw new RuntimeException("Invalid age");
        }
        
        // Validate gender if provided
        if (isset($data['gender'])) {
            $validGenders = ['Male', 'Female'];
            if (!in_array($data['gender'], $validGenders)) {
                throw new RuntimeException("Invalid gender");
            }
        }
        
        // Validate shelter if provided
        if (isset($data['shelter_id'])) {
            if (!$this->shelterModel->findById($data['shelter_id'])) {
                throw new RuntimeException("Invalid shelter ID");
            }
        }
        
        // Validate traits if provided
        if (isset($data['traits'])) {
            foreach ($data['traits'] as $traitId) {
                if (!$this->traitModel->findById($traitId)) {
                    throw new RuntimeException("Invalid trait ID: $traitId");
                }
            }
        }
        
        // Update pet
        $this->petModel->update($id, $data);
        return $this->petModel->findById($id);
    }
    
    public function deletePet(int $id): bool {
        // Verify pet exists
        $pet = $this->petModel->findById($id);
        if (!$pet) {
            throw new RuntimeException("Pet not found");
        }
        
        // Check if pet has any pending adoption applications
        // This would be implemented when we add the adoption system
        
        return $this->petModel->delete($id);
    }
    
    public function getPet(int $id): array {
        $pet = $this->petModel->findById($id);
        if (!$pet) {
            throw new RuntimeException("Pet not found");
        }
        return $pet;
    }
    
    public function listPets(array $filters = []): array {
        // Validate filters
        if (isset($filters['age_min']) && $filters['age_min'] < 0) {
            throw new RuntimeException("Minimum age cannot be negative");
        }
        
        if (isset($filters['age_max']) && $filters['age_max'] > 30) {
            throw new RuntimeException("Maximum age cannot exceed 30");
        }
        
        if (isset($filters['species'])) {
            $validSpecies = ['Dog', 'Cat', 'Bird', 'Rabbit', 'Other'];
            if (!in_array($filters['species'], $validSpecies)) {
                throw new RuntimeException("Invalid species filter");
            }
        }
        
        return $this->petModel->findAll($filters);
    }
    
    public function addTrait(string $traitName): array {
        // Validate trait name
        if (empty(trim($traitName))) {
            throw new RuntimeException("Trait name cannot be empty");
        }
        
        $traitId = $this->traitModel->create($traitName);
        return $this->traitModel->findById($traitId);
    }
    
    public function listTraits(): array {
        return $this->traitModel->findAll();
    }
}
=== ./backend/src/services/README.md ===
# Services Directory
Business logic for:
- Pet Matching Algorithm
- Adoption Processing
- Quiz Processing
- Blog Management
- Affiliate Management
=== ./backend/src/services/QuizService.php ===
<?php
// src/services/QuizService.php
namespace PawPath\services;

use PawPath\models\StartingQuiz;
use PawPath\models\QuizResult;
use PawPath\models\Pet;

class QuizService {
    private StartingQuiz $startingQuiz;
    private QuizResult $quizResult;
    private Pet $petModel;
    
    // Question weights for scoring
    private const QUESTION_WEIGHTS = [
        'living_space' => 2.0,    // High impact on pet suitability
        'activity_level' => 1.5,  // Important for energy matching
        'time_available' => 1.5,  // Critical for care requirements
        'experience' => 1.0,      // Influences training needs
        'children' => 1.8,        // Important for safety
        'other_pets' => 1.0,      // Affects compatibility
        'budget' => 1.3,          // Practical consideration
        'allergies' => 2.0,       // Critical health factor
        'noise_tolerance' => 1.2  // Environmental factor
    ];
    
    public function __construct() {
        $this->startingQuiz = new StartingQuiz();
        $this->quizResult = new QuizResult();
        $this->petModel = new Pet();
    }
    
    public function getQuizQuestions(): array {
        return [
            'sections' => [
                [
                    'id' => 'living_situation',
                    'title' => 'Living Situation',
                    'questions' => [
                        [
                            'id' => 'living_space',
                            'text' => 'What type of home do you live in?',
                            'type' => 'single_choice',
                            'options' => [
                                'apartment_small' => 'Small Apartment',
                                'apartment_large' => 'Large Apartment',
                                'house_small' => 'Small House',
                                'house_large' => 'Large House with Yard'
                            ],
                            'weight' => self::QUESTION_WEIGHTS['living_space']
                        ],
                        [
                            'id' => 'outdoor_access',
                            'text' => 'Do you have access to outdoor space?',
                            'type' => 'multiple_choice',
                            'options' => [
                                'private_yard' => 'Private Yard',
                                'shared_yard' => 'Shared Yard/Garden',
                                'nearby_park' => 'Nearby Park',
                                'no_outdoor' => 'Limited Outdoor Access'
                            ]
                        ],
                        [
                            'id' => 'rental_restrictions',
                            'text' => 'Do you have any pet restrictions where you live?',
                            'type' => 'multiple_choice',
                            'options' => [
                                'no_restrictions' => 'No Restrictions',
                                'size_limits' => 'Size/Weight Limits',
                                'breed_restrictions' => 'Breed Restrictions',
                                'no_dogs' => 'No Dogs Allowed',
                                'no_cats' => 'No Cats Allowed'
                            ]
                        ]
                    ]
                ],
                [
                    'id' => 'lifestyle',
                    'title' => 'Your Lifestyle',
                    'questions' => [
                        [
                            'id' => 'activity_level',
                            'text' => 'How would you describe your activity level?',
                            'type' => 'single_choice',
                            'options' => [
                                'very_active' => 'Very Active (Daily Exercise)',
                                'moderate' => 'Moderately Active',
                                'somewhat' => 'Somewhat Active',
                                'sedentary' => 'Mostly Sedentary'
                            ],
                            'weight' => self::QUESTION_WEIGHTS['activity_level']
                        ],
                        [
                            'id' => 'time_available',
                            'text' => 'How much time can you dedicate to pet care daily?',
                            'type' => 'single_choice',
                            'options' => [
                                'very_limited' => 'Less than 1 hour',
                                'limited' => '1-2 hours',
                                'moderate' => '2-4 hours',
                                'extensive' => '4+ hours'
                            ],
                            'weight' => self::QUESTION_WEIGHTS['time_available']
                        ],
                        [
                            'id' => 'work_schedule',
                            'text' => 'What best describes your work/daily schedule?',
                            'type' => 'single_choice',
                            'options' => [
                                'home_all_day' => 'Home Most of the Day',
                                'regular_hours' => 'Regular 9-5 Schedule',
                                'long_hours' => 'Long Hours Away',
                                'variable' => 'Variable/Unpredictable Schedule'
                            ]
                        ]
                    ]
                ],
                [
                    'id' => 'household',
                    'title' => 'Household Information',
                    'questions' => [
                        [
                            'id' => 'children',
                            'text' => 'Are there children in your household?',
                            'type' => 'multiple_choice',
                            'options' => [
                                'no_children' => 'No Children',
                                'young_children' => 'Young Children (0-6)',
                                'older_children' => 'Older Children (7-12)',
                                'teenagers' => 'Teenagers (13+)'
                            ],
                            'weight' => self::QUESTION_WEIGHTS['children']
                        ],
                        [
                            'id' => 'other_pets',
                            'text' => 'Do you have other pets?',
                            'type' => 'multiple_choice',
                            'options' => [
                                'no_pets' => 'No Other Pets',
                                'dogs' => 'Dogs',
                                'cats' => 'Cats',
                                'other_pets' => 'Other Pets'
                            ],
                            'weight' => self::QUESTION_WEIGHTS['other_pets']
                        ]
                    ]
                ],
                [
                    'id' => 'experience',
                    'title' => 'Pet Experience',
                    'questions' => [
                        [
                            'id' => 'pet_experience',
                            'text' => 'What is your experience with pets?',
                            'type' => 'single_choice',
                            'options' => [
                                'first_time' => 'First-time Pet Owner',
                                'some_experience' => 'Some Experience',
                                'experienced' => 'Experienced Pet Owner',
                                'professional' => 'Professional Experience'
                            ],
                            'weight' => self::QUESTION_WEIGHTS['experience']
                        ],
                        [
                            'id' => 'training_willingness',
                            'text' => 'Are you willing to attend training classes or work with a trainer?',
                            'type' => 'single_choice',
                            'options' => [
                                'definitely' => 'Definitely',
                                'maybe' => 'Maybe if Needed',
                                'prefer_not' => 'Prefer Not To',
                                'no' => 'Not Interested'
                            ]
                        ]
                    ]
                ],
                [
                    'id' => 'practical_considerations',
                    'title' => 'Practical Considerations',
                    'questions' => [
                        [
                            'id' => 'budget',
                            'text' => 'What is your monthly budget for pet care (including food, supplies, and routine vet care)?',
                            'type' => 'single_choice',
                            'options' => [
                                'limited' => 'Under $50',
                                'moderate' => '$50-$100',
                                'flexible' => '$100-$200',
                                'unlimited' => '$200+'
                            ],
                            'weight' => self::QUESTION_WEIGHTS['budget']
                        ],
                        [
                            'id' => 'grooming',
                            'text' => 'How much grooming are you willing to do?',
                            'type' => 'single_choice',
                            'options' => [
                                'minimal' => 'Minimal (Basic Care)',
                                'moderate' => 'Moderate (Weekly Grooming)',
                                'high' => 'High (Daily Grooming)',
                                'professional' => 'Will Use Professional Groomer'
                            ]
                        ],
                        [
                            'id' => 'allergies',
                            'text' => 'Does anyone in your household have pet allergies?',
                            'type' => 'multiple_choice',
                            'options' => [
                                'no_allergies' => 'No Allergies',
                                'cat_allergies' => 'Cat Allergies',
                                'dog_allergies' => 'Dog Allergies',
                                'other_allergies' => 'Other Animal Allergies'
                            ],
                            'weight' => self::QUESTION_WEIGHTS['allergies']
                        ]
                    ]
                ],
                [
                    'id' => 'preferences',
                    'title' => 'Pet Preferences',
                    'questions' => [
                        [
                            'id' => 'size_preference',
                            'text' => 'What size pet are you looking for?',
                            'type' => 'multiple_choice',
                            'options' => [
                                'small' => 'Small',
                                'medium' => 'Medium',
                                'large' => 'Large',
                                'no_preference' => 'No Preference'
                            ]
                        ],
                        [
                            'id' => 'noise_tolerance',
                            'text' => 'How much noise can you tolerate from a pet?',
                            'type' => 'single_choice',
                            'options' => [
                                'silent' => 'Prefer Silent Pets',
                                'some_noise' => 'Some Noise is OK',
                                'moderate' => 'Moderate Barking/Noise OK',
                                'any_noise' => 'Noise Doesn\'t Bother Me'
                            ],
                            'weight' => self::QUESTION_WEIGHTS['noise_tolerance']
                        ],
                        [
                            'id' => 'exercise_commitment',
                            'text' => 'How much exercise can you provide?',
                            'type' => 'single_choice',
                            'options' => [
                                'minimal' => 'Minimal (Short Walks)',
                                'moderate' => 'Moderate (Daily Walks)',
                                'active' => 'Active (Long Walks/Play)',
                                'very_active' => 'Very Active (Running/Hiking)'
                            ]
                        ]
                    ]
                ]
        ]
    ];
}
     
    public function processQuiz(int $userId, array $answers): array {
        try {
            // Create new quiz entry
            $quizId = $this->startingQuiz->create($userId);
            
            // Analyze answers and generate recommendations
            $analysis = $this->analyzeAnswers($answers);
            
            // Calculate confidence score
            $confidenceScore = $this->calculateConfidenceScore($answers);
            
            // Save results
            $resultData = [
                'quiz_id' => $quizId,
                'recommended_species' => $analysis['recommended_species'],
                'recommended_breed' => $analysis['recommended_breed'],
                'trait_preferences' => $analysis['trait_preferences'],
                'confidence_score' => $confidenceScore
            ];
            
            $resultId = $this->quizResult->create($resultData);
            
            // Find matching pets
            $matchingPets = $this->findMatchingPets($analysis);
            
            return [
                'quiz_id' => $quizId,
                'result_id' => $resultId,
                'recommendations' => $analysis,
                'confidence_score' => $confidenceScore,
                'matching_pets' => $matchingPets
            ];
        } catch (\Exception $e) {
            error_log("Error processing quiz: " . $e->getMessage());
            throw $e;
        }
    }
        
    private function analyzeAnswers(array $answers): array {
        $speciesScores = [
            'dog' => 0,
            'cat' => 0,
            'bird' => 0,
            'rabbit' => 0
        ];
        
        // Use associative array to prevent duplicates
        $traitPreferences = [];
        
        // Helper function to add trait
        $addTrait = function($trait, $value) use (&$traitPreferences) {
            $traitPreferences[$trait] = [
                'trait' => $trait,
                'value' => $value
            ];
        };
        
        // Process living situation
        if (isset($answers['living_situation'])) {
            if (isset($answers['living_situation']['living_space'])) {
                switch ($answers['living_situation']['living_space']) {
                    case 'house_large':
                        $speciesScores['dog'] += 2 * self::QUESTION_WEIGHTS['living_space'];
                        $addTrait('High Energy', 'binary');
                        $addTrait('Easily Trained', 'binary');
                        break;
                    case 'apartment_small':
                        $speciesScores['cat'] += 2 * self::QUESTION_WEIGHTS['living_space'];
                        $addTrait('Apartment Friendly', 'binary');
                        $addTrait('Calm', 'binary');
                        break;
                }
            }
        }
        
        // Process lifestyle
        if (isset($answers['lifestyle'])) {
            if (isset($answers['lifestyle']['activity_level'])) {
                switch ($answers['lifestyle']['activity_level']) {
                    case 'very_active':
                        $speciesScores['dog'] += 2 * self::QUESTION_WEIGHTS['activity_level'];
                        $addTrait('High Energy', 'binary');
                        break;
                    case 'moderate':
                        $addTrait('Easily Trained', 'binary');
                        break;
                    case 'sedentary':
                        $speciesScores['cat'] += 1.5;
                        $addTrait('Calm', 'binary');
                        break;
                }
            }
        }
        
        // Convert trait preferences back to array
        $traitPreferences = array_values($traitPreferences);
        
        // Normalize scores
        $maxScore = max($speciesScores);
        if ($maxScore > 0) {
            array_walk($speciesScores, function(&$score) use ($maxScore) {
                $score = round(($score / $maxScore) * 100, 2);
            });
        }
        
        return [
            'recommended_species' => array_search(max($speciesScores), $speciesScores),
            'recommended_breed' => null,
            'trait_preferences' => $traitPreferences,
            'species_scores' => $speciesScores
        ];
    }
    
    private function calculateConfidenceScore(array $answers): float {
        $answeredQuestions = 0;
        $totalQuestions = 0;
        
        foreach ($answers as $section) {
            if (is_array($section)) {
                foreach ($section as $value) {
                    $totalQuestions++;
                    if (!empty($value)) {
                        $answeredQuestions++;
                    }
                }
            }
        }
        
        return $totalQuestions > 0 ? 
            round(($answeredQuestions / $totalQuestions) * 100, 2) : 0;
    }
    
    private function findMatchingPets(array $analysis): array {
        $filters = [
            'species' => $analysis['recommended_species'],
            'breed' => $analysis['recommended_breed'] ?? null,
            'traits' => array_map(function($trait) {
                return [
                    'trait' => $trait['trait'],
                    'value' => $trait['value']
                ];
            }, $analysis['trait_preferences'])
        ];
        
        error_log("Finding matching pets with filters: " . json_encode($filters, JSON_PRETTY_PRINT));
        return $this->petModel->findAllWithTraits($filters);
    }
    
    private function getBreedRecommendation(string $species, array $traits, array $answers): ?string {
        // Implement breed recommendation logic based on species and traits
        // This would be expanded based on specific breed characteristics
        return null; // Placeholder
    }
    
    private function convertTraitPreferencesToFilters(array $preferences): array {
        $filters = [];
        foreach ($preferences as $trait => $value) {
            $filters[] = [
                'trait' => $trait,
                'value' => $value
            ];
        }
        return $filters;
    }
}
=== ./backend/tests/test_pet_matching.php ===
<?php
// backend/tests/test_pet_matching.php

require_once __DIR__ . '/../vendor/autoload.php';

use Dotenv\Dotenv;
use PawPath\models\Pet;

class TestHelper {
    private PDO $pdo;
    private Pet $petModel;
    
    public function __construct() {
        $dotenv = Dotenv::createImmutable(__DIR__ . '/..');
        $dotenv->load();
        
        $this->connectToDatabase();
        $this->petModel = new Pet();
    }
    
    private function connectToDatabase(): void {
        $dsn = sprintf(
            "mysql:host=%s;port=%s;dbname=%s;charset=utf8mb4",
            $_ENV['DB_HOST'],
            $_ENV['DB_PORT'] ?? '3306',
            $_ENV['DB_DATABASE']
        );
        
        $this->pdo = new PDO($dsn, $_ENV['DB_USERNAME'], $_ENV['DB_PASSWORD'], [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
        ]);
        
        echo "Database connection successful\n";
    }
    
    public function cleanupTestData(): void {
        $this->pdo->exec("DELETE FROM Pet_Trait_Relation WHERE pet_id IN (SELECT pet_id FROM Pet WHERE shelter_id IN (SELECT shelter_id FROM Shelter WHERE email = 'test@shelter.com'))");
        $this->pdo->exec("DELETE FROM Pet WHERE shelter_id IN (SELECT shelter_id FROM Shelter WHERE email = 'test@shelter.com')");
        $this->pdo->exec("DELETE FROM Shelter WHERE email = 'test@shelter.com'");
        echo "Cleaned up existing test data\n";
    }
    
    public function createTestShelter(): int {
        $stmt = $this->pdo->prepare("
            INSERT INTO Shelter (name, address, phone, email, is_no_kill)
            VALUES ('Test Shelter', '123 Test St', '555-0123', 'test@shelter.com', 1)
        ");
        $stmt->execute();
        $shelterId = (int) $this->pdo->lastInsertId();
        echo "Created test shelter with ID: $shelterId\n\n";
        return $shelterId;
    }
    
    public function getAvailableTraits(): array {
        $stmt = $this->pdo->query("
            SELECT t.trait_id, t.trait_name, tc.name as category, t.value_type
            FROM Pet_Trait t
            JOIN Trait_Category tc ON t.category_id = tc.category_id
            ORDER BY tc.name, t.trait_name
        ");
        $traits = $stmt->fetchAll(PDO::FETCH_ASSOC);
        
        echo "Available traits by category:\n";
        $currentCategory = '';
        foreach ($traits as $trait) {
            if ($currentCategory !== $trait['category']) {
                $currentCategory = $trait['category'];
                echo "\n{$trait['category']}:\n";
            }
            echo "  - {$trait['trait_name']} (ID: {$trait['trait_id']}, Type: {$trait['value_type']})\n";
        }
        echo "\n";
        
        return $traits;
    }
    
    public function createTestPets(int $shelterId, array $traits): array {
        $highEnergyTrait = array_filter($traits, fn($t) => $t['trait_name'] === 'High Energy');
        $goodWithKidsTrait = array_filter($traits, fn($t) => $t['trait_name'] === 'Good with kids');
        $highEnergyTrait = reset($highEnergyTrait);
        $goodWithKidsTrait = reset($goodWithKidsTrait);
        
        if (!$highEnergyTrait || !$goodWithKidsTrait) {
            throw new Exception("Could not find required traits");
        }
        
        $testPets = [
            [
                'name' => 'Luna',
                'species' => 'dog',
                'breed' => 'Golden Retriever',
                'age' => 2,
                'gender' => 'female',
                'description' => 'Friendly and energetic Golden Retriever',
                'shelter_id' => $shelterId,
                'traits' => [$highEnergyTrait['trait_id'], $goodWithKidsTrait['trait_id']]
            ],
            [
                'name' => 'Max',
                'species' => 'dog',
                'breed' => 'German Shepherd',
                'age' => 3,
                'gender' => 'male',
                'description' => 'Intelligent and loyal German Shepherd',
                'shelter_id' => $shelterId,
                'traits' => [$goodWithKidsTrait['trait_id']]
            ]
        ];
        
        $petIds = [];
        foreach ($testPets as $petData) {
            try {
                $petIds[] = $this->petModel->create($petData);
                echo "Created {$petData['name']} successfully\n";
            } catch (Exception $e) {
                echo "Error creating {$petData['name']}: " . $e->getMessage() . "\n";
            }
        }
        
        return $petIds;
    }
        
    public function testTraitMatching(array $traits): void {
        echo "\nTesting trait matching functionality:\n";
        echo "\n";
        
        $filters = [
            'species' => 'dog',
            'traits' => [
                ['trait' => 'High Energy'],
                ['trait' => 'Good with kids']
            ]
        ];
        
        echo "Searching for dogs with traits: High Energy, Good with kids\n\n";
        
        $matchingPets = $this->petModel->findAllWithTraits($filters);
        echo "Found " . count($matchingPets) . " matching pets:\n\n";
        
        foreach ($matchingPets as $pet) {
            echo "\n";
            echo " {$pet['name']} ({$pet['breed']})\n";
            echo " Matching traits: {$pet['matching_trait_count']}\n";
            echo " Traits by category:\n";
            
            if (!empty($pet['traits'])) {
                foreach ($pet['traits'] as $category => $traits) {
                    echo "    {$category}: " . implode(', ', $traits) . "\n";
                }
            } else {
                echo "   No traits assigned\n";
            }
            
            echo "\n\n";
        }
    }

    public function cleanup(array $petIds, int $shelterId): void {
        echo "\nCleaning up test data...\n";
        foreach ($petIds as $petId) {
            $this->petModel->delete($petId);
            echo "Deleted pet ID: $petId\n";
        }
        
        $stmt = $this->pdo->prepare("DELETE FROM Shelter WHERE shelter_id = ?");
        $stmt->execute([$shelterId]);
        echo "Deleted test shelter\n";
    }
}

// Run the tests
try {
    $tester = new TestHelper();
    
    // Setup
    $tester->cleanupTestData();
    $shelterId = $tester->createTestShelter();
    $traits = $tester->getAvailableTraits();
    
    // Create test pets
    $petIds = $tester->createTestPets($shelterId, $traits);
    
    // Test trait matching
    $tester->testTraitMatching($traits);
    
    // Cleanup
    $tester->cleanup($petIds, $shelterId);
    
} catch (Exception $e) {
    echo "Error: " . $e->getMessage() . "\n";
    exit(1);
}
=== ./backend/tests/setup_traits.php ===
<?php
// backend/tests/setup_traits.php

require_once __DIR__ . '/../vendor/autoload.php';

use Dotenv\Dotenv;

// Update the path to look in the backend directory
$dotenv = Dotenv::createImmutable(__DIR__ . '/..');
$dotenv->load();

// Add debug output
echo "Environment variables loaded:\n";
echo "DB_HOST: " . $_ENV['DB_HOST'] . "\n";
echo "DB_DATABASE: " . $_ENV['DB_DATABASE'] . "\n";
echo "DB_USERNAME: " . $_ENV['DB_USERNAME'] . "\n";
echo "DB_PASSWORD is set: " . (isset($_ENV['DB_PASSWORD']) ? "Yes" : "No") . "\n";

try {
    $dsn = "mysql:host=" . $_ENV['DB_HOST'] . ";port=" . ($_ENV['DB_PORT'] ?? "3306") . ";dbname=" . $_ENV['DB_DATABASE'] . ";charset=utf8mb4";
    echo "Attempting to connect with DSN: $dsn\n";
    
    $pdo = new PDO($dsn, $_ENV['DB_USERNAME'], $_ENV['DB_PASSWORD'], [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
    ]);
    
    echo "Database connection successful!\n\n";

    // First, create categories if they don't exist
    $categories = [
        ['name' => 'energy_level', 'description' => 'Activity and exercise needs'],
        ['name' => 'social', 'description' => 'Social characteristics'],
        ['name' => 'training', 'description' => 'Training characteristics']
    ];

    foreach ($categories as $category) {
        $stmt = $pdo->prepare("
            INSERT IGNORE INTO Trait_Category (name, description)
            VALUES (?, ?)
        ");
        $stmt->execute([$category['name'], $category['description']]);
        echo "Processed category: {$category['name']}\n";
    }

    // Then create basic traits if they don't exist
    $traits = [
        ['name' => 'High Energy', 'category' => 'energy_level', 'type' => 'binary'],
        ['name' => 'Good with Kids', 'category' => 'social', 'type' => 'scale'],
        ['name' => 'Easily Trained', 'category' => 'training', 'type' => 'binary']
    ];

    foreach ($traits as $trait) {
        // Get category ID
        $stmt = $pdo->prepare("SELECT category_id FROM Trait_Category WHERE name = ?");
        $stmt->execute([$trait['category']]);
        $categoryId = $stmt->fetchColumn();
        
        if ($categoryId) {
            $stmt = $pdo->prepare("
                INSERT IGNORE INTO Pet_Trait (trait_name, category_id, value_type)
                VALUES (?, ?, ?)
            ");
            $stmt->execute([$trait['name'], $categoryId, $trait['type']]);
            echo "Processed trait: {$trait['name']}\n";
        } else {
            echo "Warning: Category {$trait['category']} not found for trait {$trait['name']}\n";
        }
    }

    echo "\nTrait setup complete!\n";
    
} catch (Exception $e) {
    echo "Error: " . $e->getMessage() . "\n";
    exit(1);
}
=== ./backend/tests/test_pets.php ===
<?php
// backend/tests/test_pets.php

require __DIR__ . '/../vendor/autoload.php';

// Load environment variables
$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
$dotenv->load();

use PawPath\models\Pet;
use PawPath\models\PetTrait;

// Create instances
$petModel = new Pet();
$traitModel = new PetTrait();

// Get existing traits or create new ones
try {
    $traits = $traitModel->findAll();
    if (empty($traits)) {
        echo "Testing Pet Trait Model...\n";
        
        // Create some traits
        $friendlyId = $traitModel->create("Friendly");
        echo "Created trait 'Friendly' with ID: $friendlyId\n";
        
        $gentleId = $traitModel->create("Gentle");
        echo "Created trait 'Gentle' with ID: $gentleId\n";
        
        // List all traits
        $traits = $traitModel->findAll();
        echo "All traits:\n";
        print_r($traits);
    } else {
        $friendlyId = $traits[0]['trait_id'];
        $gentleId = $traits[1]['trait_id'];
    }
    
    echo "\nTesting Pet Model...\n";
    
    // Create a pet - Use the shelter_id from your actual shelter
    $shelter_id = 3; // Replace with your actual shelter ID from the GET shelters request
    
    try {
        $shelterModel = new \PawPath\models\Shelter();
        $shelter = $shelterModel->findById($shelter_id);
        if (!$shelter) {
            throw new \RuntimeException("Shelter with ID $shelter_id not found");
        }
    } catch (Exception $e) {
        echo "Error checking shelter: " . $e->getMessage() . "\n";
        exit(1);
    }

    echo "Using shelter: " . $shelter['name'] . "\n";

    $petData = [
        'name' => 'Max',
        'species' => 'dog',
        'breed' => 'Golden Retriever',
        'age' => 3,
        'gender' => 'Male',
        'description' => 'A very good boy',
        'shelter_id' => $shelter_id,
        'traits' => [$friendlyId, $gentleId]
    ];
    
    echo "Creating pet with shelter_id: $shelter_id\n";
    $petId = $petModel->create($petData);
    echo "Created pet with ID: $petId\n";
    
    // Retrieve the pet
    $pet = $petModel->findById($petId);
    echo "Retrieved pet:\n";
    print_r($pet);
    
    // Update the pet
    $updateData = [
        'age' => 4,
        'description' => 'A very good and friendly boy'
    ];
    $petModel->update($petId, $updateData);
    
    // Retrieve updated pet
    $updatedPet = $petModel->findById($petId);
    echo "\nUpdated pet:\n";
    print_r($updatedPet);
    
    // Test search functionality
    $searchResults = $petModel->findAll(['species' => 'dog']);
    echo "\nSearch results for dogs:\n";
    print_r($searchResults);
    
} catch (Exception $e) {
    echo "Error: " . $e->getMessage() . "\n";
    echo "Stack trace:\n" . $e->getTraceAsString() . "\n";
}
=== ./backend/tests/test_quiz_controller.php ===
<?php
require_once __DIR__ . '/../vendor/autoload.php';

use Dotenv\Dotenv;
use PawPath\models\Pet;
use PawPath\api\QuizController;
use PawPath\models\StartingQuiz;
use PawPath\models\QuizResult;

class TestQuizHelper {
    private PDO $pdo;
    private $userId = 1; // We'll use this as our test user ID
    
    public function __construct() {
        $dotenv = Dotenv::createImmutable(__DIR__ . '/..');
        $dotenv->load();
        
        $this->connectToDatabase();
    }
    
    private function connectToDatabase(): void {
        $dsn = sprintf(
            "mysql:host=%s;port=%s;dbname=%s;charset=utf8mb4",
            $_ENV['DB_HOST'],
            $_ENV['DB_PORT'] ?? '3306',
            $_ENV['DB_DATABASE']
        );
        
        $this->pdo = new PDO($dsn, $_ENV['DB_USERNAME'], $_ENV['DB_PASSWORD'], [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
        ]);
        
        echo "Database connection successful\n";
    }
    
    public function cleanupTestData(): void {
        // Delete test pets and relations first
        $this->pdo->exec("
            DELETE ptr FROM Pet_Trait_Relation ptr
            INNER JOIN Pet p ON ptr.pet_id = p.pet_id
            INNER JOIN Shelter s ON p.shelter_id = s.shelter_id
            WHERE s.email = 'test@shelter.com'
        ");
        
        $this->pdo->exec("
            DELETE p FROM Pet p
            INNER JOIN Shelter s ON p.shelter_id = s.shelter_id
            WHERE s.email = 'test@shelter.com'
        ");
        
        // Delete test shelter
        $this->pdo->exec("DELETE FROM Shelter WHERE email = 'test@shelter.com'");
        
        // Clean up quiz data
        $this->pdo->exec("
            DELETE qr FROM Quiz_Result qr
            INNER JOIN Starting_Quiz sq ON qr.quiz_id = sq.quiz_id
            WHERE sq.user_id = 1
        ");
        $this->pdo->exec("DELETE FROM Starting_Quiz WHERE user_id = 1");
        
        echo "Cleaned up existing test data\n";
    }
    
    public function setupTestData(): array {
        // Create test shelter
        $stmt = $this->pdo->prepare("
            INSERT INTO Shelter (name, address, phone, email, is_no_kill)
            VALUES ('Test Shelter', '123 Test St', '555-0123', 'test@shelter.com', 1)
        ");
        $stmt->execute();
        $shelterId = $this->pdo->lastInsertId();
        
        echo "Created test shelter with ID: $shelterId\n";
        
        // Create test pets with traits
        $pets = [
            [
                'name' => 'Luna',
                'species' => 'dog',
                'breed' => 'Golden Retriever',
                'age' => 2,
                'gender' => 'female',
                'description' => 'Energetic and friendly Golden',
                'traits' => ['High Energy', 'Good with kids', 'Easily Trained']
            ],
            [
                'name' => 'Max',
                'species' => 'dog',
                'breed' => 'German Shepherd',
                'age' => 3,
                'gender' => 'male',
                'description' => 'Intelligent and active shepherd',
                'traits' => ['High Energy', 'Easily Trained']
            ]
        ];
        
        foreach ($pets as $petData) {
            // Insert pet
            $stmt = $this->pdo->prepare("
                INSERT INTO Pet (name, species, breed, age, gender, description, shelter_id)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ");
            
            $stmt->execute([
                $petData['name'],
                $petData['species'],
                $petData['breed'],
                $petData['age'],
                $petData['gender'],
                $petData['description'],
                $shelterId
            ]);
            
            $petId = $this->pdo->lastInsertId();
            echo "Created test pet {$petData['name']} with ID: $petId\n";
            
            // Add traits
            foreach ($petData['traits'] as $traitName) {
                // Get trait ID
                $stmt = $this->pdo->prepare("
                    SELECT trait_id FROM Pet_Trait WHERE trait_name = ?
                ");
                $stmt->execute([$traitName]);
                $traitId = $stmt->fetchColumn();
                
                if ($traitId) {
                    // Add trait relation
                    $stmt = $this->pdo->prepare("
                        INSERT INTO Pet_Trait_Relation (pet_id, trait_id)
                        VALUES (?, ?)
                    ");
                    $stmt->execute([$petId, $traitId]);
                    echo "Added trait '$traitName' to pet {$petData['name']}\n";
                } else {
                    echo "Warning: Trait '$traitName' not found in database\n";
                }
            }
        }
        
        return ['shelter_id' => $shelterId];
    }

    private function createTestRequest(array $data = [], array $attributes = []): \Slim\Psr7\Request {
        $request = new \Slim\Psr7\Request(
            'POST',
            new \Slim\Psr7\Uri('http', 'localhost', 80, '/api/quiz/submit'),
            new \Slim\Psr7\Headers(['Content-Type' => 'application/json']),
            [],
            [],
            new \Slim\Psr7\Stream(fopen('php://temp', 'r+')),
            []
        );
        
        // Add body data
        if (!empty($data)) {
            $body = json_encode($data);
            if ($body === false) {
                throw new \RuntimeException("Failed to encode request data: " . json_last_error_msg());
            }
            
            $stream = fopen('php://temp', 'r+');
            if ($stream === false) {
                throw new \RuntimeException("Failed to open stream");
            }
            
            fwrite($stream, $body);
            rewind($stream);
            
            $request = $request->withBody(new \Slim\Psr7\Stream($stream));
        }
        
        // Add attributes (like user_id)
        foreach ($attributes as $key => $value) {
            $request = $request->withAttribute($key, $value);
        }
        
        return $request;
    }
    
    private function createTestResponse(): \Slim\Psr7\Response {
        return new \Slim\Psr7\Response();
    }
    
    public function runTests(): void {
        echo "\nRunning Quiz Controller Tests\n";
        echo "\n\n";
        
        $this->testStartQuiz();
        $this->testSubmitQuiz();
        $this->testQuizHistory();
        $this->testSpecificQuizResult();
    }
    
    private function testStartQuiz(): void {
        echo "Test 1: Starting a New Quiz\n";
        echo "\n";
        
        try {
            $controller = new QuizController();
            $response = $controller->startQuiz(
                $this->createTestRequest(),
                $this->createTestResponse()
            );
            
            $result = json_decode((string)$response->getBody(), true);
            
            if ($result['success']) {
                echo " Successfully retrieved quiz questions\n";
                echo " Found " . $result['data']['total_sections'] . " question sections\n";
                foreach ($result['data']['questions']['sections'] as $section) {
                    echo "   {$section['title']}: " . count($section['questions']) . " questions\n";
                }
            } else {
                echo " Failed to start quiz\n";
            }
        } catch (Exception $e) {
            echo " Error: " . $e->getMessage() . "\n";
        }
        echo "\n";
    }
    
    private function testSubmitQuiz(): void {
        echo "Test 2: Submitting Quiz Answers\n";
        echo "\n";
        
        try {
            $controller = new QuizController();
            
            $answers = [
                'answers' => [
                    'living_situation' => [
                        'living_space' => 'house_large',
                        'outdoor_access' => ['private_yard'],
                        'rental_restrictions' => ['no_restrictions']
                    ],
                    'lifestyle' => [
                        'activity_level' => 'very_active',
                        'time_available' => 'extensive',
                        'work_schedule' => 'regular_hours'
                    ],
                    'household' => [
                        'children' => ['no_children'],
                        'other_pets' => ['no_pets']
                    ],
                    'experience' => [
                        'pet_experience' => 'experienced',
                        'training_willingness' => 'definitely'
                    ],
                    'practical_considerations' => [
                        'budget' => 'flexible',
                        'grooming' => 'high',
                        'allergies' => ['no_allergies']
                    ],
                    'preferences' => [
                        'size_preference' => ['medium'],
                        'noise_tolerance' => 'moderate',
                        'exercise_commitment' => 'active'
                    ]
                ]
            ];
            
            echo "Submitting answers: " . json_encode($answers, JSON_PRETTY_PRINT) . "\n";
            
            $response = $controller->submitQuiz(
                $this->createTestRequest($answers, ['user_id' => $this->userId]),
                $this->createTestResponse()
            );
            
            $result = json_decode((string)$response->getBody(), true);
            
            if ($result['success']) {
                echo " Successfully submitted quiz answers\n";
                echo " Received recommendations:\n";
                echo "   Recommended species: " . $result['data']['recommendations']['species'] . "\n";
                if (!empty($result['data']['recommendations']['breed'])) {
                    echo "   Recommended breed: " . $result['data']['recommendations']['breed'] . "\n";
                }
                echo "   Confidence score: " . $result['data']['confidence_score'] . "%\n";
                echo "   Found " . count($result['data']['matching_pets']) . " matching pets\n";
                
                if (!empty($result['data']['matching_pets'])) {
                    echo "\nMatching pets:\n";
                    foreach ($result['data']['matching_pets'] as $pet) {
                        echo "   {$pet['name']} ({$pet['breed']})\n";
                        if (!empty($pet['traits'])) {
                            echo "    Traits:\n";
                            foreach ($pet['traits'] as $category => $traits) {
                                echo "      - $category: " . implode(', ', $traits) . "\n";
                            }
                        }
                    }
                }
                
                $this->lastQuizId = $result['data']['quiz_id'];
            } else {
                echo " Failed to submit quiz\n";
                echo "Error: " . ($result['message'] ?? 'Unknown error') . "\n";
            }
        } catch (Exception $e) {
            echo " Error: " . $e->getMessage() . "\n";
            echo "Stack trace:\n" . $e->getTraceAsString() . "\n";
        }
        echo "\n";
    }
    
    private function testQuizHistory(): void {
        echo "Test 3: Retrieving Quiz History\n";
        echo "\n";
        
        try {
            $controller = new QuizController();
            $response = $controller->getQuizHistory(
                $this->createTestRequest([], ['user_id' => $this->userId]),
                $this->createTestResponse()
            );
            
            $result = json_decode((string)$response->getBody(), true);
            
            if ($result['success']) {
                echo " Successfully retrieved quiz history\n";
                echo " Found " . $result['data']['total_quizzes'] . " previous quizzes\n";
                foreach ($result['data']['history'] as $quiz) {
                    echo "   Quiz {$quiz['quiz_id']} taken on {$quiz['date_taken']}\n";
                    echo "    Recommended: {$quiz['recommendations']['species']}\n";
                }
            } else {
                echo " Failed to retrieve quiz history\n";
            }
        } catch (Exception $e) {
            echo " Error: " . $e->getMessage() . "\n";
        }
        echo "\n";
    }
    
    private function testSpecificQuizResult(): void {
        echo "Test 4: Retrieving Specific Quiz Result\n";
        echo "\n";
        
        if (!isset($this->lastQuizId)) {
            echo " No quiz ID available for testing\n\n";
            return;
        }
        
        try {
            $controller = new QuizController();
            $response = $controller->getQuizResult(
                $this->createTestRequest([], ['user_id' => $this->userId]),
                $this->createTestResponse(),
                ['id' => $this->lastQuizId]
            );
            
            $result = json_decode((string)$response->getBody(), true);
            
            if ($result['success']) {
                echo " Successfully retrieved quiz result\n";
                echo " Quiz details:\n";
                echo "   Date taken: " . $result['data']['date_taken'] . "\n";
                echo "   Recommended species: " . $result['data']['recommendations']['species'] . "\n";
                if (!empty($result['data']['recommendations']['breed'])) {
                    echo "   Recommended breed: " . $result['data']['recommendations']['breed'] . "\n";
                }
                echo "   Trait preferences: " . count($result['data']['recommendations']['traits']) . " traits\n";
            } else {
                echo " Failed to retrieve quiz result\n";
            }
        } catch (Exception $e) {
            echo " Error: " . $e->getMessage() . "\n";
        }
        echo "\n";
    }
}

// Run the tests
try {
    $tester = new TestQuizHelper();
    
    // Clean up any existing test data
    $tester->cleanupTestData();
    
    // Setup test data
    $testData = $tester->setupTestData();
    
    // Run all tests
    $tester->runTests();
    
} catch (Exception $e) {
    echo "Error: " . $e->getMessage() . "\n";
    exit(1);
}
=== ./backend/tests/test_pet_service.php ===
<?php
// backend/tests/test_pet_service.php

require __DIR__ . '/../vendor/autoload.php';

// Load environment variables
$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
$dotenv->load();

use PawPath\services\PetService;

$petService = new PetService();

function printSection($title) {
    echo "\n" . str_repeat("=", 50) . "\n";
    echo $title . "\n";
    echo str_repeat("=", 50) . "\n";
}

try {
    // Test trait management
    printSection("Testing Trait Management");
    
    echo "Adding new traits...\n";
    $playful = $petService->addTrait("Playful");
    echo "Added trait: ";
    print_r($playful);
    
    $quiet = $petService->addTrait("Quiet");
    echo "Added trait: ";
    print_r($quiet);
    
    echo "\nListing all traits:\n";
    $allTraits = $petService->listTraits();
    print_r($allTraits);
    
    // Test pet creation
    printSection("Testing Pet Creation");
    
    // Test validation - should fail
    echo "\nTesting validation with missing required fields...\n";
    try {
        $petService->createPet([
            'name' => 'Buddy'
            // Missing required fields
        ]);
    } catch (RuntimeException $e) {
        echo "Caught expected error: " . $e->getMessage() . "\n";
    }
    
    // Create valid pet
    echo "\nCreating valid pet...\n";
    $petData = [
        'name' => 'Buddy',
        'species' => 'Dog',
        'breed' => 'Labrador',
        'age' => 2,
        'gender' => 'Male',
        'description' => 'A friendly lab who loves to play',
        'shelter_id' => 3, // Use your actual shelter ID
        'traits' => [$playful['trait_id'], $quiet['trait_id']]
    ];
    
    $newPet = $petService->createPet($petData);
    echo "Created new pet:\n";
    print_r($newPet);
    
    // Test pet retrieval
    printSection("Testing Pet Retrieval");
    
    $retrievedPet = $petService->getPet($newPet['pet_id']);
    echo "Retrieved pet:\n";
    print_r($retrievedPet);
    
    // Test pet update
    printSection("Testing Pet Update");
    
    $updateData = [
        'age' => 3,
        'description' => 'A friendly lab who loves to play and is great with kids'
    ];
    
    $updatedPet = $petService->updatePet($newPet['pet_id'], $updateData);
    echo "Updated pet:\n";
    print_r($updatedPet);
    
    // Test invalid update
    echo "\nTesting invalid update (invalid age)...\n";
    try {
        $petService->updatePet($newPet['pet_id'], ['age' => -1]);
    } catch (RuntimeException $e) {
        echo "Caught expected error: " . $e->getMessage() . "\n";
    }
    
    // Test pet listing with filters
    printSection("Testing Pet Listing with Filters");
    
    echo "\nListing all dogs:\n";
    $dogs = $petService->listPets(['species' => 'Dog']);
    print_r($dogs);
    
    echo "\nTesting invalid species filter...\n";
    try {
        $petService->listPets(['species' => 'Dragon']);
    } catch (RuntimeException $e) {
        echo "Caught expected error: " . $e->getMessage() . "\n";
    }
    
    // Test deletion (optional)
    /*
    printSection("Testing Pet Deletion");
    
    $deleted = $petService->deletePet($newPet['pet_id']);
    echo "Pet deleted: " . ($deleted ? "true" : "false") . "\n";
    
    // Verify deletion
    try {
        $petService->getPet($newPet['pet_id']);
    } catch (RuntimeException $e) {
        echo "Caught expected error: " . $e->getMessage() . "\n";
    }
    */
    
} catch (Exception $e) {
    echo "\nUnexpected error occurred: " . $e->getMessage() . "\n";
    echo "Stack trace:\n" . $e->getTraceAsString() . "\n";
}
=== ./backend/api_tests.sh ===
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'  # No Color

# Base URL
BASE_URL="http://localhost:8000/api"
TOKEN=""
TIMESTAMP=$(date +%s)

# Test data
QUIZ_DATA='{
    "answers": {
        "living_situation": {
            "living_space": "house_large",
            "outdoor_access": ["private_yard"],
            "rental_restrictions": ["no_restrictions"]
        },
        "lifestyle": {
            "activity_level": "very_active",
            "time_available": "extensive",
            "work_schedule": "regular_hours"
        }
    }
}'

# Global test counters
TOTAL_TESTS=0
PASSED_TESTS=0
TOTAL_CHECKS=0
PASSED_CHECKS=0

# Helper Functions
verify_match() {
    local expected="$1"
    local actual="$2"
    local description="$3"
    TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
    TOTAL_TESTS=$((TOTAL_TESTS + 1))
    if [ "$expected" = "$actual" ]; then
        PASSED_CHECKS=$((PASSED_CHECKS + 1))
        PASSED_TESTS=$((PASSED_TESTS + 1))
        echo -e "${GREEN}${NC} $description ($actual)"
    else
        echo -e "${RED}${NC} $description - Expected: $expected, Got: $actual"
    fi
}

make_request() {
    local method=$1
    local endpoint=$2
    local data=$3
    
    local curl_cmd="curl -s -X $method"
    curl_cmd="$curl_cmd -H 'Content-Type: application/json'"
    
    if [ ! -z "$TOKEN" ]; then
        curl_cmd="$curl_cmd -H 'Authorization: Bearer ${TOKEN}'"
    fi
    
    if [ ! -z "$data" ]; then
        curl_cmd="$curl_cmd -d '${data}'"
    fi
    
    # Debug output to stderr
    echo " ${method} ${endpoint}" >&2
    
    # Execute request
    eval $curl_cmd "'${BASE_URL}${endpoint}'"
}

summarize_quiz_response() {
    local response="$1"
    echo "Quiz Results Summary:"
    echo "  Recommendations:"
    
    local species=$(echo $response | jq -r '.data.recommendations.species // "Not specified"')
    echo "    Species: $species"
    
    echo -n "    Traits: "
    local traits=$(echo $response | jq -r '.data.recommendations.traits[]?.trait // empty' 2>/dev/null | tr '\n' ', ' || echo "None")
    echo "${traits%,}"  # Remove trailing comma
    
    local matching_pets=$(echo $response | jq -r '.data.matching_pets | length // 0')
    echo "  Matching Pets: $matching_pets"
    
    local confidence=$(echo $response | jq -r '.data.confidence_score // 0')
    echo "  Confidence Score: ${confidence}%"
}

# Test Functions
test_auth() {
    TOTAL_CHECKS=0
    PASSED_CHECKS=0
    
    echo -e "\n${BLUE}Testing Authentication Endpoints${NC}"
    echo ""
    
    echo "Step 1: Testing Registration..."
    local register_data='{
        "username": "testuser_'${TIMESTAMP}'",
        "email": "test_'${TIMESTAMP}'@example.com",
        "password": "password123"
    }'
    
    local register_response=$(make_request "POST" "/auth/register" "$register_data")
    verify_match "true" "$(echo $register_response | jq 'has("token")')" "Registration successful"
    
    echo -e "\nStep 2: Testing Login..."
    local login_data='{
        "email": "test@example.com",
        "password": "password123"
    }'
    
    local login_response=$(make_request "POST" "/auth/login" "$login_data")
    TOKEN=$(echo $login_response | jq -r '.token')
    
    if [ "$TOKEN" != "null" ] && [ "$TOKEN" != "" ]; then
        echo -e "${GREEN}${NC} Authentication token obtained"
        export TOKEN
    else
        echo -e "${RED}${NC} Failed to obtain authentication token"
        exit 1
    fi

    TOTAL_TESTS=$((TOTAL_TESTS + 1))
    [ $PASSED_CHECKS -eq $TOTAL_CHECKS ] && PASSED_TESTS=$((PASSED_TESTS + 1))
}

test_shelters() {
    TOTAL_CHECKS=0
    PASSED_CHECKS=0
    
    echo -e "\n${BLUE}Testing Shelter Endpoints${NC}"
    echo ""
    
    echo "Step 1: Creating shelter..."
    local shelter_data='{
        "name": "Test Shelter_'${TIMESTAMP}'",
        "address": "123 Test St",
        "phone": "555-0123",
        "email": "shelter_'${TIMESTAMP}'@test.com",
        "is_no_kill": true
    }'
    
    local shelter_response=$(make_request "POST" "/shelters" "$shelter_data")
    local SHELTER_ID=$(echo $shelter_response | jq -r '.shelter_id')
    verify_match "true" "$(echo $shelter_response | jq 'has("shelter_id")')" "Shelter created"
    
    echo -e "\nStep 2: Verifying shelter details..."
    local get_response=$(make_request "GET" "/shelters/$SHELTER_ID")
    verify_match "Test Shelter_${TIMESTAMP}" "$(echo $get_response | jq -r '.name')" "Shelter name"
    verify_match "123 Test St" "$(echo $get_response | jq -r '.address')" "Shelter address"
    
    echo -e "\nStep 3: Checking shelter list..."
    local list_response=$(make_request "GET" "/shelters")
    local shelter_count=$(echo $list_response | jq '. | length')
    echo "Total shelters: $shelter_count"

    TOTAL_TESTS=$((TOTAL_TESTS + 1))
    [ $PASSED_CHECKS -eq $TOTAL_CHECKS ] && PASSED_TESTS=$((PASSED_TESTS + 1))
}

test_pets() {
    TOTAL_CHECKS=0
    PASSED_CHECKS=0
    
    echo -e "\n${BLUE}Testing Pet Endpoints${NC}"
    echo ""
    
    echo "Step 1: Creating test shelter..."
    local shelter_data='{
        "name": "Test Pet Shelter_'${TIMESTAMP}'",
        "address": "456 Pet St",
        "phone": "555-0124",
        "email": "pet_'${TIMESTAMP}'@shelter.com",
        "is_no_kill": true
    }'
    
    local shelter_response=$(make_request "POST" "/shelters" "$shelter_data")
    local SHELTER_ID=$(echo $shelter_response | jq -r '.shelter_id')
    echo " Created shelter ID: $SHELTER_ID"
    
    if [ "$SHELTER_ID" != "null" ] && [ "$SHELTER_ID" != "" ]; then
        echo -e "\nStep 2: Creating pet..."
        local pet_data='{
            "name": "Max_'${TIMESTAMP}'",
            "species": "Dog",
            "breed": "Golden Retriever",
            "age": 2,
            "gender": "Male",
            "description": "A friendly dog looking for a home",
            "shelter_id": '$SHELTER_ID'
        }'
        
        local pet_response=$(make_request "POST" "/pets" "$pet_data")
        local PET_ID=$(echo $pet_response | jq -r '.data.pet_id')
        echo " Created pet ID: $PET_ID"
        
        if [ "$PET_ID" != "null" ] && [ "$PET_ID" != "" ]; then
            echo -e "\nStep 3: Verifying pet details..."
            local get_response=$(make_request "GET" "/pets/$PET_ID")
            
            echo "Basic Details:"
            verify_match "Max_${TIMESTAMP}" "$(echo $get_response | jq -r '.name')" "Name"
            verify_match "Dog" "$(echo $get_response | jq -r '.species')" "Species"
            verify_match "Golden Retriever" "$(echo $get_response | jq -r '.breed')" "Breed"
            verify_match "2" "$(echo $get_response | jq -r '.age')" "Age"
            verify_match "Male" "$(echo $get_response | jq -r '.gender')" "Gender"
            
            echo -e "\nShelter Relationship:"
            verify_match "$SHELTER_ID" "$(echo $get_response | jq -r '.shelter_id')" "Shelter ID"
            verify_match "Test Pet Shelter_${TIMESTAMP}" "$(echo $get_response | jq -r '.shelter_name')" "Shelter Name"
            
            echo -e "\nStep 4: Verifying pet in list..."
            local list_response=$(make_request "GET" "/pets")
            local pet_in_list=$(echo $list_response | jq --arg pid "$PET_ID" '.[] | select(.pet_id == ($pid|tonumber))')
            
            if [ ! -z "$pet_in_list" ]; then
                echo -e "${GREEN} Pet found in list ${NC}"
                verify_match "true" "$(echo $pet_in_list | jq 'has("traits")')" "Has traits array"
            else
                echo -e "${RED} Pet not found in list ${NC}"
            fi
        fi
    fi
    
    echo -e "\nTest Summary:"
    echo ""
    echo "Total Verifications: $TOTAL_CHECKS"
    echo "Passed: $PASSED_CHECKS"
    echo "Failed: $((TOTAL_CHECKS - PASSED_CHECKS))"

    TOTAL_TESTS=$((TOTAL_TESTS + 1))
    [ $PASSED_CHECKS -eq $TOTAL_CHECKS ] && PASSED_TESTS=$((PASSED_TESTS + 1))
}

test_quiz() {
    TOTAL_CHECKS=0
    PASSED_CHECKS=0
    
    echo -e "\n${BLUE}Testing Quiz Endpoints${NC}"
    echo ""
    
    echo "Step 1: Starting quiz..."
    local start_response=$(make_request "GET" "/quiz/start")
    local sections_count=$(echo $start_response | jq -r '.data.total_sections')
    verify_match "6" "$sections_count" "Quiz sections loaded"
    
    echo -e "\nStep 2: Submitting quiz answers..."
    local quiz_response=$(make_request "POST" "/quiz/submit" "$QUIZ_DATA")
    summarize_quiz_response "$quiz_response"
    
    echo -e "\nStep 3: Checking quiz history..."
    local history_response=$(make_request "GET" "/quiz/history")
    local total_quizzes=$(echo $history_response | jq -r '.data.total_quizzes')
    verify_match "true" "$([ $total_quizzes -gt 0 ] && echo true || echo false)" "Quiz history exists"
    echo "Found $total_quizzes quizzes in history"

    TOTAL_TESTS=$((TOTAL_TESTS + 1))
    [ $PASSED_CHECKS -eq $TOTAL_CHECKS ] && PASSED_TESTS=$((PASSED_TESTS + 1))
}

# Main execution
echo "Starting API Tests"
echo "=========================="

test_auth
test_shelters
test_pets
test_quiz

echo -e "\n${BLUE}Test Suite Summary${NC}"
echo ""
echo "Total Test Groups: 4"
echo "Individual Checks Run: $TOTAL_TESTS"
echo "Checks Passed: $PASSED_TESTS"
echo "Checks Failed: $((TOTAL_TESTS - PASSED_TESTS))"
echo -e "Overall Status: $([ $PASSED_TESTS -eq $TOTAL_TESTS ] && echo "${GREEN}All Tests Passed${NC}" || echo "${RED}Some Tests Failed${NC}")"
echo -e "\nAPI Tests Completed"
=== ./backend/public/index.php ===
<?php
// backend/public/index.php

error_reporting(E_ALL);
ini_set('display_errors', 1);

use Slim\Factory\AppFactory;
use DI\Container;
use PawPath\api\AuthController;
use PawPath\api\ShelterController;
use PawPath\api\PetController;
use PawPath\api\QuizController;
use PawPath\api\AdoptionController;
use PawPath\middleware\AuthMiddleware;

require __DIR__ . '/../vendor/autoload.php';

// Create Container
$container = new Container();
AppFactory::setContainer($container);

// Create App
$app = AppFactory::create();

// Add body parsing middleware
$app->addBodyParsingMiddleware();

// Add error middleware
$app->addErrorMiddleware(true, true, true);

// Public routes
$app->post('/api/auth/register', function ($request, $response) {
    $controller = new AuthController();
    return $controller->register($request, $response);
});

$app->post('/api/auth/login', function ($request, $response) {
    $controller = new AuthController();
    return $controller->login($request, $response);
});

// Protected routes group
$app->group('/api', function ($group) {
    // Quiz routes
    $group->get('/quiz/start', function ($request, $response) {
        $controller = new QuizController();
        return $controller->startQuiz($request, $response);
    });
    
    $group->post('/quiz/submit', function ($request, $response) {
        $controller = new QuizController();
        return $controller->submitQuiz($request, $response);
    });
    
    $group->get('/quiz/history', function ($request, $response) {
        $controller = new QuizController();
        return $controller->getQuizHistory($request, $response);
    });
    
    $group->get('/quiz/{id}', function ($request, $response, $args) {
        $controller = new QuizController();
        return $controller->getQuizResult($request, $response, $args);
    });
    
    // Shelter routes
    $group->post('/shelters', function ($request, $response) {
        $controller = new ShelterController();
        return $controller->createShelter($request, $response);
    });
    
    $group->get('/shelters', function ($request, $response) {
        $controller = new ShelterController();
        return $controller->listShelters($request, $response);
    });
    
    $group->get('/shelters/{id}', function ($request, $response, $args) {
        $controller = new ShelterController();
        return $controller->getShelter($request, $response, $args);
    });
    
    $group->put('/shelters/{id}', function ($request, $response, $args) {
        $controller = new ShelterController();
        return $controller->updateShelter($request, $response, $args);
    });
    
    $group->delete('/shelters/{id}', function ($request, $response, $args) {
        $controller = new ShelterController();
        return $controller->deleteShelter($request, $response, $args);
    });
    
    // Pet routes
    $group->post('/pets', function ($request, $response) {
        $controller = new PetController();
        return $controller->createPet($request, $response);
    });
    
    $group->get('/pets', function ($request, $response) {
        $controller = new PetController();
        return $controller->listPets($request, $response);
    });
    
    $group->get('/pets/{id}', function ($request, $response, $args) {
        $controller = new PetController();
        return $controller->getPet($request, $response, $args);
    });
    
    $group->put('/pets/{id}', function ($request, $response, $args) {
        $controller = new PetController();
        return $controller->updatePet($request, $response, $args);
    });
    
    $group->delete('/pets/{id}', function ($request, $response, $args) {
        $controller = new PetController();
        return $controller->deletePet($request, $response, $args);
    });
    
    // Pet trait routes
    $group->post('/pet-traits', function ($request, $response) {
        $controller = new PetController();
        return $controller->createTrait($request, $response);
    });
    
    $group->get('/pet-traits', function ($request, $response) {
        $controller = new PetController();
        return $controller->listTraits($request, $response);
    });
    
    // Adoption Application routes
    $group->post('/adoptions', function ($request, $response) {
        $controller = new AdoptionController();
        return $controller->submitApplication($request, $response);
    });
    
    $group->get('/adoptions/user', function ($request, $response) {
        $controller = new AdoptionController();
        return $controller->getUserApplications($request, $response);
    });
    
    $group->get('/adoptions/shelter/{shelter_id}', function ($request, $response, $args) {
        $controller = new AdoptionController();
        return $controller->getShelterApplications($request, $response, $args);
    });
    
    $group->get('/adoptions/pet/{pet_id}', function ($request, $response, $args) {
        $controller = new AdoptionController();
        return $controller->getPetApplications($request, $response, $args);
    });
    
    $group->get('/adoptions/{id}', function ($request, $response, $args) {
        $controller = new AdoptionController();
        return $controller->getApplication($request, $response, $args);
    });
    
    $group->put('/adoptions/{id}/status', function ($request, $response, $args) {
        $controller = new AdoptionController();
        return $controller->updateApplicationStatus($request, $response, $args);
    });
})->add(new AuthMiddleware());

// Run the app
$app->run();
=== ./backend/composer.json ===
{
    "name": "pawpath/pet-adoption",
    "description": "PawPath - Pet Adoption Database and Community Platform",
    "type": "project",
    "require": {
        "php": "^8.1",
        "slim/slim": "^4.11",
        "slim/psr7": "^1.7",
        "php-di/php-di": "^7.0",
        "vlucas/phpdotenv": "^5.5",
        "firebase/php-jwt": "^6.4"
    },
    "autoload": {
        "psr-4": {
            "PawPath\\": "src/"
        }
    }
}
=== ./backend/sudo ===
=== ./backend/database/schema.sql ===
=== ./backend/.env ===
DB_HOST=localhost
DB_PORT=3306
DB_DATABASE=pawpath
DB_USERNAME=root
DB_PASSWORD=Michael369!
APP_ENV=development
APP_DEBUG=true
APP_KEY=base64:VeryLongRandomStringForTesting123456789
# If you're using JWT for authentication
JWT_SECRET=AnotherRandomStringForJwtTesting123456789
=== ./backend/README.md ===
# PawPath Backend

This directory contains the PHP backend for the PawPath pet adoption platform.
=== ./backend/composer.lock ===
{
    "_readme": [
        "This file locks the dependencies of your project to a known state",
        "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies",
        "This file is @generated automatically"
    ],
    "content-hash": "2044128a1b9a2859b18658fc4941a783",
    "packages": [
        {
            "name": "fig/http-message-util",
            "version": "1.1.5",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-message-util.git",
                "reference": "9d94dc0154230ac39e5bf89398b324a86f63f765"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-message-util/zipball/9d94dc0154230ac39e5bf89398b324a86f63f765",
                "reference": "9d94dc0154230ac39e5bf89398b324a86f63f765",
                "shasum": ""
            },
            "require": {
                "php": "^5.3 || ^7.0 || ^8.0"
            },
            "suggest": {
                "psr/http-message": "The package containing the PSR-7 interfaces"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.1.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Fig\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Utility classes and constants for use with PSR-7 (psr/http-message)",
            "keywords": [
                "http",
                "http-message",
                "psr",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "issues": "https://github.com/php-fig/http-message-util/issues",
                "source": "https://github.com/php-fig/http-message-util/tree/1.1.5"
            },
            "time": "2020-11-24T22:02:12+00:00"
        },
        {
            "name": "firebase/php-jwt",
            "version": "v6.10.1",
            "source": {
                "type": "git",
                "url": "https://github.com/firebase/php-jwt.git",
                "reference": "500501c2ce893c824c801da135d02661199f60c5"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/firebase/php-jwt/zipball/500501c2ce893c824c801da135d02661199f60c5",
                "reference": "500501c2ce893c824c801da135d02661199f60c5",
                "shasum": ""
            },
            "require": {
                "php": "^8.0"
            },
            "require-dev": {
                "guzzlehttp/guzzle": "^7.4",
                "phpspec/prophecy-phpunit": "^2.0",
                "phpunit/phpunit": "^9.5",
                "psr/cache": "^2.0||^3.0",
                "psr/http-client": "^1.0",
                "psr/http-factory": "^1.0"
            },
            "suggest": {
                "ext-sodium": "Support EdDSA (Ed25519) signatures",
                "paragonie/sodium_compat": "Support EdDSA (Ed25519) signatures when libsodium is not present"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Firebase\\JWT\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Neuman Vong",
                    "email": "neuman+pear@twilio.com",
                    "role": "Developer"
                },
                {
                    "name": "Anant Narayanan",
                    "email": "anant@php.net",
                    "role": "Developer"
                }
            ],
            "description": "A simple library to encode and decode JSON Web Tokens (JWT) in PHP. Should conform to the current spec.",
            "homepage": "https://github.com/firebase/php-jwt",
            "keywords": [
                "jwt",
                "php"
            ],
            "support": {
                "issues": "https://github.com/firebase/php-jwt/issues",
                "source": "https://github.com/firebase/php-jwt/tree/v6.10.1"
            },
            "time": "2024-05-18T18:05:11+00:00"
        },
        {
            "name": "graham-campbell/result-type",
            "version": "v1.1.3",
            "source": {
                "type": "git",
                "url": "https://github.com/GrahamCampbell/Result-Type.git",
                "reference": "3ba905c11371512af9d9bdd27d99b782216b6945"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/GrahamCampbell/Result-Type/zipball/3ba905c11371512af9d9bdd27d99b782216b6945",
                "reference": "3ba905c11371512af9d9bdd27d99b782216b6945",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5 || ^8.0",
                "phpoption/phpoption": "^1.9.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^8.5.39 || ^9.6.20 || ^10.5.28"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "GrahamCampbell\\ResultType\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Graham Campbell",
                    "email": "hello@gjcampbell.co.uk",
                    "homepage": "https://github.com/GrahamCampbell"
                }
            ],
            "description": "An Implementation Of The Result Type",
            "keywords": [
                "Graham Campbell",
                "GrahamCampbell",
                "Result Type",
                "Result-Type",
                "result"
            ],
            "support": {
                "issues": "https://github.com/GrahamCampbell/Result-Type/issues",
                "source": "https://github.com/GrahamCampbell/Result-Type/tree/v1.1.3"
            },
            "funding": [
                {
                    "url": "https://github.com/GrahamCampbell",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/graham-campbell/result-type",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-20T21:45:45+00:00"
        },
        {
            "name": "laravel/serializable-closure",
            "version": "v1.3.5",
            "source": {
                "type": "git",
                "url": "https://github.com/laravel/serializable-closure.git",
                "reference": "1dc4a3dbfa2b7628a3114e43e32120cce7cdda9c"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/laravel/serializable-closure/zipball/1dc4a3dbfa2b7628a3114e43e32120cce7cdda9c",
                "reference": "1dc4a3dbfa2b7628a3114e43e32120cce7cdda9c",
                "shasum": ""
            },
            "require": {
                "php": "^7.3|^8.0"
            },
            "require-dev": {
                "illuminate/support": "^8.0|^9.0|^10.0|^11.0",
                "nesbot/carbon": "^2.61|^3.0",
                "pestphp/pest": "^1.21.3",
                "phpstan/phpstan": "^1.8.2",
                "symfony/var-dumper": "^5.4.11|^6.2.0|^7.0.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Laravel\\SerializableClosure\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Taylor Otwell",
                    "email": "taylor@laravel.com"
                },
                {
                    "name": "Nuno Maduro",
                    "email": "nuno@laravel.com"
                }
            ],
            "description": "Laravel Serializable Closure provides an easy and secure way to serialize closures in PHP.",
            "keywords": [
                "closure",
                "laravel",
                "serializable"
            ],
            "support": {
                "issues": "https://github.com/laravel/serializable-closure/issues",
                "source": "https://github.com/laravel/serializable-closure"
            },
            "time": "2024-09-23T13:33:08+00:00"
        },
        {
            "name": "nikic/fast-route",
            "version": "v1.3.0",
            "source": {
                "type": "git",
                "url": "https://github.com/nikic/FastRoute.git",
                "reference": "181d480e08d9476e61381e04a71b34dc0432e812"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/nikic/FastRoute/zipball/181d480e08d9476e61381e04a71b34dc0432e812",
                "reference": "181d480e08d9476e61381e04a71b34dc0432e812",
                "shasum": ""
            },
            "require": {
                "php": ">=5.4.0"
            },
            "require-dev": {
                "phpunit/phpunit": "^4.8.35|~5.7"
            },
            "type": "library",
            "autoload": {
                "files": [
                    "src/functions.php"
                ],
                "psr-4": {
                    "FastRoute\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Nikita Popov",
                    "email": "nikic@php.net"
                }
            ],
            "description": "Fast request router for PHP",
            "keywords": [
                "router",
                "routing"
            ],
            "support": {
                "issues": "https://github.com/nikic/FastRoute/issues",
                "source": "https://github.com/nikic/FastRoute/tree/master"
            },
            "time": "2018-02-13T20:26:39+00:00"
        },
        {
            "name": "php-di/invoker",
            "version": "2.3.4",
            "source": {
                "type": "git",
                "url": "https://github.com/PHP-DI/Invoker.git",
                "reference": "33234b32dafa8eb69202f950a1fc92055ed76a86"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/PHP-DI/Invoker/zipball/33234b32dafa8eb69202f950a1fc92055ed76a86",
                "reference": "33234b32dafa8eb69202f950a1fc92055ed76a86",
                "shasum": ""
            },
            "require": {
                "php": ">=7.3",
                "psr/container": "^1.0|^2.0"
            },
            "require-dev": {
                "athletic/athletic": "~0.1.8",
                "mnapoli/hard-mode": "~0.3.0",
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Invoker\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "description": "Generic and extensible callable invoker",
            "homepage": "https://github.com/PHP-DI/Invoker",
            "keywords": [
                "callable",
                "dependency",
                "dependency-injection",
                "injection",
                "invoke",
                "invoker"
            ],
            "support": {
                "issues": "https://github.com/PHP-DI/Invoker/issues",
                "source": "https://github.com/PHP-DI/Invoker/tree/2.3.4"
            },
            "funding": [
                {
                    "url": "https://github.com/mnapoli",
                    "type": "github"
                }
            ],
            "time": "2023-09-08T09:24:21+00:00"
        },
        {
            "name": "php-di/php-di",
            "version": "7.0.7",
            "source": {
                "type": "git",
                "url": "https://github.com/PHP-DI/PHP-DI.git",
                "reference": "e87435e3c0e8f22977adc5af0d5cdcc467e15cf1"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/PHP-DI/PHP-DI/zipball/e87435e3c0e8f22977adc5af0d5cdcc467e15cf1",
                "reference": "e87435e3c0e8f22977adc5af0d5cdcc467e15cf1",
                "shasum": ""
            },
            "require": {
                "laravel/serializable-closure": "^1.0",
                "php": ">=8.0",
                "php-di/invoker": "^2.0",
                "psr/container": "^1.1 || ^2.0"
            },
            "provide": {
                "psr/container-implementation": "^1.0"
            },
            "require-dev": {
                "friendsofphp/php-cs-fixer": "^3",
                "friendsofphp/proxy-manager-lts": "^1",
                "mnapoli/phpunit-easymock": "^1.3",
                "phpunit/phpunit": "^9.5",
                "vimeo/psalm": "^4.6"
            },
            "suggest": {
                "friendsofphp/proxy-manager-lts": "Install it if you want to use lazy injection (version ^1)"
            },
            "type": "library",
            "autoload": {
                "files": [
                    "src/functions.php"
                ],
                "psr-4": {
                    "DI\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "description": "The dependency injection container for humans",
            "homepage": "https://php-di.org/",
            "keywords": [
                "PSR-11",
                "container",
                "container-interop",
                "dependency injection",
                "di",
                "ioc",
                "psr11"
            ],
            "support": {
                "issues": "https://github.com/PHP-DI/PHP-DI/issues",
                "source": "https://github.com/PHP-DI/PHP-DI/tree/7.0.7"
            },
            "funding": [
                {
                    "url": "https://github.com/mnapoli",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/php-di/php-di",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-21T15:55:45+00:00"
        },
        {
            "name": "phpoption/phpoption",
            "version": "1.9.3",
            "source": {
                "type": "git",
                "url": "https://github.com/schmittjoh/php-option.git",
                "reference": "e3fac8b24f56113f7cb96af14958c0dd16330f54"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/schmittjoh/php-option/zipball/e3fac8b24f56113f7cb96af14958c0dd16330f54",
                "reference": "e3fac8b24f56113f7cb96af14958c0dd16330f54",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5 || ^8.0"
            },
            "require-dev": {
                "bamarni/composer-bin-plugin": "^1.8.2",
                "phpunit/phpunit": "^8.5.39 || ^9.6.20 || ^10.5.28"
            },
            "type": "library",
            "extra": {
                "bamarni-bin": {
                    "bin-links": true,
                    "forward-command": false
                },
                "branch-alias": {
                    "dev-master": "1.9-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "PhpOption\\": "src/PhpOption/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "Apache-2.0"
            ],
            "authors": [
                {
                    "name": "Johannes M. Schmitt",
                    "email": "schmittjoh@gmail.com",
                    "homepage": "https://github.com/schmittjoh"
                },
                {
                    "name": "Graham Campbell",
                    "email": "hello@gjcampbell.co.uk",
                    "homepage": "https://github.com/GrahamCampbell"
                }
            ],
            "description": "Option Type for PHP",
            "keywords": [
                "language",
                "option",
                "php",
                "type"
            ],
            "support": {
                "issues": "https://github.com/schmittjoh/php-option/issues",
                "source": "https://github.com/schmittjoh/php-option/tree/1.9.3"
            },
            "funding": [
                {
                    "url": "https://github.com/GrahamCampbell",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/phpoption/phpoption",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-20T21:41:07+00:00"
        },
        {
            "name": "psr/container",
            "version": "2.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/container.git",
                "reference": "c71ecc56dfe541dbd90c5360474fbc405f8d5963"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/container/zipball/c71ecc56dfe541dbd90c5360474fbc405f8d5963",
                "reference": "c71ecc56dfe541dbd90c5360474fbc405f8d5963",
                "shasum": ""
            },
            "require": {
                "php": ">=7.4.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Container\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common Container Interface (PHP FIG PSR-11)",
            "homepage": "https://github.com/php-fig/container",
            "keywords": [
                "PSR-11",
                "container",
                "container-interface",
                "container-interop",
                "psr"
            ],
            "support": {
                "issues": "https://github.com/php-fig/container/issues",
                "source": "https://github.com/php-fig/container/tree/2.0.2"
            },
            "time": "2021-11-05T16:47:00+00:00"
        },
        {
            "name": "psr/http-factory",
            "version": "1.1.0",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-factory.git",
                "reference": "2b4765fddfe3b508ac62f829e852b1501d3f6e8a"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-factory/zipball/2b4765fddfe3b508ac62f829e852b1501d3f6e8a",
                "reference": "2b4765fddfe3b508ac62f829e852b1501d3f6e8a",
                "shasum": ""
            },
            "require": {
                "php": ">=7.1",
                "psr/http-message": "^1.0 || ^2.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "PSR-17: Common interfaces for PSR-7 HTTP message factories",
            "keywords": [
                "factory",
                "http",
                "message",
                "psr",
                "psr-17",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "source": "https://github.com/php-fig/http-factory"
            },
            "time": "2024-04-15T12:06:14+00:00"
        },
        {
            "name": "psr/http-message",
            "version": "2.0",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-message.git",
                "reference": "402d35bcb92c70c026d1a6a9883f06b2ead23d71"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-message/zipball/402d35bcb92c70c026d1a6a9883f06b2ead23d71",
                "reference": "402d35bcb92c70c026d1a6a9883f06b2ead23d71",
                "shasum": ""
            },
            "require": {
                "php": "^7.2 || ^8.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP messages",
            "homepage": "https://github.com/php-fig/http-message",
            "keywords": [
                "http",
                "http-message",
                "psr",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "source": "https://github.com/php-fig/http-message/tree/2.0"
            },
            "time": "2023-04-04T09:54:51+00:00"
        },
        {
            "name": "psr/http-server-handler",
            "version": "1.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-server-handler.git",
                "reference": "84c4fb66179be4caaf8e97bd239203245302e7d4"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-server-handler/zipball/84c4fb66179be4caaf8e97bd239203245302e7d4",
                "reference": "84c4fb66179be4caaf8e97bd239203245302e7d4",
                "shasum": ""
            },
            "require": {
                "php": ">=7.0",
                "psr/http-message": "^1.0 || ^2.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Server\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP server-side request handler",
            "keywords": [
                "handler",
                "http",
                "http-interop",
                "psr",
                "psr-15",
                "psr-7",
                "request",
                "response",
                "server"
            ],
            "support": {
                "source": "https://github.com/php-fig/http-server-handler/tree/1.0.2"
            },
            "time": "2023-04-10T20:06:20+00:00"
        },
        {
            "name": "psr/http-server-middleware",
            "version": "1.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-server-middleware.git",
                "reference": "c1481f747daaa6a0782775cd6a8c26a1bf4a3829"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-server-middleware/zipball/c1481f747daaa6a0782775cd6a8c26a1bf4a3829",
                "reference": "c1481f747daaa6a0782775cd6a8c26a1bf4a3829",
                "shasum": ""
            },
            "require": {
                "php": ">=7.0",
                "psr/http-message": "^1.0 || ^2.0",
                "psr/http-server-handler": "^1.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Server\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP server-side middleware",
            "keywords": [
                "http",
                "http-interop",
                "middleware",
                "psr",
                "psr-15",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "issues": "https://github.com/php-fig/http-server-middleware/issues",
                "source": "https://github.com/php-fig/http-server-middleware/tree/1.0.2"
            },
            "time": "2023-04-11T06:14:47+00:00"
        },
        {
            "name": "psr/log",
            "version": "3.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/log.git",
                "reference": "f16e1d5863e37f8d8c2a01719f5b34baa2b714d3"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/log/zipball/f16e1d5863e37f8d8c2a01719f5b34baa2b714d3",
                "reference": "f16e1d5863e37f8d8c2a01719f5b34baa2b714d3",
                "shasum": ""
            },
            "require": {
                "php": ">=8.0.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "3.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Log\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for logging libraries",
            "homepage": "https://github.com/php-fig/log",
            "keywords": [
                "log",
                "psr",
                "psr-3"
            ],
            "support": {
                "source": "https://github.com/php-fig/log/tree/3.0.2"
            },
            "time": "2024-09-11T13:17:53+00:00"
        },
        {
            "name": "ralouphie/getallheaders",
            "version": "3.0.3",
            "source": {
                "type": "git",
                "url": "https://github.com/ralouphie/getallheaders.git",
                "reference": "120b605dfeb996808c31b6477290a714d356e822"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/ralouphie/getallheaders/zipball/120b605dfeb996808c31b6477290a714d356e822",
                "reference": "120b605dfeb996808c31b6477290a714d356e822",
                "shasum": ""
            },
            "require": {
                "php": ">=5.6"
            },
            "require-dev": {
                "php-coveralls/php-coveralls": "^2.1",
                "phpunit/phpunit": "^5 || ^6.5"
            },
            "type": "library",
            "autoload": {
                "files": [
                    "src/getallheaders.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Ralph Khattar",
                    "email": "ralph.khattar@gmail.com"
                }
            ],
            "description": "A polyfill for getallheaders.",
            "support": {
                "issues": "https://github.com/ralouphie/getallheaders/issues",
                "source": "https://github.com/ralouphie/getallheaders/tree/develop"
            },
            "time": "2019-03-08T08:55:37+00:00"
        },
        {
            "name": "slim/psr7",
            "version": "1.7.0",
            "source": {
                "type": "git",
                "url": "https://github.com/slimphp/Slim-Psr7.git",
                "reference": "753e9646def5ff4db1a06e5cf4ef539bfd30f467"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/slimphp/Slim-Psr7/zipball/753e9646def5ff4db1a06e5cf4ef539bfd30f467",
                "reference": "753e9646def5ff4db1a06e5cf4ef539bfd30f467",
                "shasum": ""
            },
            "require": {
                "fig/http-message-util": "^1.1.5",
                "php": "^8.0",
                "psr/http-factory": "^1.1",
                "psr/http-message": "^1.0 || ^2.0",
                "ralouphie/getallheaders": "^3.0",
                "symfony/polyfill-php80": "^1.29"
            },
            "provide": {
                "psr/http-factory-implementation": "^1.0",
                "psr/http-message-implementation": "^1.0 || ^2.0"
            },
            "require-dev": {
                "adriansuter/php-autoload-override": "^1.4",
                "ext-json": "*",
                "http-interop/http-factory-tests": "^1.1.0",
                "php-http/psr7-integration-tests": "1.3.0",
                "phpspec/prophecy": "^1.19",
                "phpspec/prophecy-phpunit": "^2.2",
                "phpstan/phpstan": "^1.11",
                "phpunit/phpunit": "^9.6",
                "squizlabs/php_codesniffer": "^3.10"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Slim\\Psr7\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Josh Lockhart",
                    "email": "hello@joshlockhart.com",
                    "homepage": "http://joshlockhart.com"
                },
                {
                    "name": "Andrew Smith",
                    "email": "a.smith@silentworks.co.uk",
                    "homepage": "http://silentworks.co.uk"
                },
                {
                    "name": "Rob Allen",
                    "email": "rob@akrabat.com",
                    "homepage": "http://akrabat.com"
                },
                {
                    "name": "Pierre Berube",
                    "email": "pierre@lgse.com",
                    "homepage": "http://www.lgse.com"
                }
            ],
            "description": "Strict PSR-7 implementation",
            "homepage": "https://www.slimframework.com",
            "keywords": [
                "http",
                "psr-7",
                "psr7"
            ],
            "support": {
                "issues": "https://github.com/slimphp/Slim-Psr7/issues",
                "source": "https://github.com/slimphp/Slim-Psr7/tree/1.7.0"
            },
            "time": "2024-06-08T14:48:17+00:00"
        },
        {
            "name": "slim/slim",
            "version": "4.14.0",
            "source": {
                "type": "git",
                "url": "https://github.com/slimphp/Slim.git",
                "reference": "5943393b88716eb9e82c4161caa956af63423913"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/slimphp/Slim/zipball/5943393b88716eb9e82c4161caa956af63423913",
                "reference": "5943393b88716eb9e82c4161caa956af63423913",
                "shasum": ""
            },
            "require": {
                "ext-json": "*",
                "nikic/fast-route": "^1.3",
                "php": "^7.4 || ^8.0",
                "psr/container": "^1.0 || ^2.0",
                "psr/http-factory": "^1.1",
                "psr/http-message": "^1.1 || ^2.0",
                "psr/http-server-handler": "^1.0",
                "psr/http-server-middleware": "^1.0",
                "psr/log": "^1.1 || ^2.0 || ^3.0"
            },
            "require-dev": {
                "adriansuter/php-autoload-override": "^1.4",
                "ext-simplexml": "*",
                "guzzlehttp/psr7": "^2.6",
                "httpsoft/http-message": "^1.1",
                "httpsoft/http-server-request": "^1.1",
                "laminas/laminas-diactoros": "^2.17 || ^3",
                "nyholm/psr7": "^1.8",
                "nyholm/psr7-server": "^1.1",
                "phpspec/prophecy": "^1.19",
                "phpspec/prophecy-phpunit": "^2.1",
                "phpstan/phpstan": "^1.11",
                "phpunit/phpunit": "^9.6",
                "slim/http": "^1.3",
                "slim/psr7": "^1.6",
                "squizlabs/php_codesniffer": "^3.10",
                "vimeo/psalm": "^5.24"
            },
            "suggest": {
                "ext-simplexml": "Needed to support XML format in BodyParsingMiddleware",
                "ext-xml": "Needed to support XML format in BodyParsingMiddleware",
                "php-di/php-di": "PHP-DI is the recommended container library to be used with Slim",
                "slim/psr7": "Slim PSR-7 implementation. See https://www.slimframework.com/docs/v4/start/installation.html for more information."
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Slim\\": "Slim"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Josh Lockhart",
                    "email": "hello@joshlockhart.com",
                    "homepage": "https://joshlockhart.com"
                },
                {
                    "name": "Andrew Smith",
                    "email": "a.smith@silentworks.co.uk",
                    "homepage": "http://silentworks.co.uk"
                },
                {
                    "name": "Rob Allen",
                    "email": "rob@akrabat.com",
                    "homepage": "http://akrabat.com"
                },
                {
                    "name": "Pierre Berube",
                    "email": "pierre@lgse.com",
                    "homepage": "http://www.lgse.com"
                },
                {
                    "name": "Gabriel Manricks",
                    "email": "gmanricks@me.com",
                    "homepage": "http://gabrielmanricks.com"
                }
            ],
            "description": "Slim is a PHP micro framework that helps you quickly write simple yet powerful web applications and APIs",
            "homepage": "https://www.slimframework.com",
            "keywords": [
                "api",
                "framework",
                "micro",
                "router"
            ],
            "support": {
                "docs": "https://www.slimframework.com/docs/v4/",
                "forum": "https://discourse.slimframework.com/",
                "irc": "irc://irc.freenode.net:6667/slimphp",
                "issues": "https://github.com/slimphp/Slim/issues",
                "rss": "https://www.slimframework.com/blog/feed.rss",
                "slack": "https://slimphp.slack.com/",
                "source": "https://github.com/slimphp/Slim",
                "wiki": "https://github.com/slimphp/Slim/wiki"
            },
            "funding": [
                {
                    "url": "https://opencollective.com/slimphp",
                    "type": "open_collective"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/slim/slim",
                    "type": "tidelift"
                }
            ],
            "time": "2024-06-13T08:54:48+00:00"
        },
        {
            "name": "symfony/polyfill-ctype",
            "version": "v1.31.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-ctype.git",
                "reference": "a3cc8b044a6ea513310cbd48ef7333b384945638"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-ctype/zipball/a3cc8b044a6ea513310cbd48ef7333b384945638",
                "reference": "a3cc8b044a6ea513310cbd48ef7333b384945638",
                "shasum": ""
            },
            "require": {
                "php": ">=7.2"
            },
            "provide": {
                "ext-ctype": "*"
            },
            "suggest": {
                "ext-ctype": "For best performance"
            },
            "type": "library",
            "extra": {
                "thanks": {
                    "name": "symfony/polyfill",
                    "url": "https://github.com/symfony/polyfill"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ],
                "psr-4": {
                    "Symfony\\Polyfill\\Ctype\\": ""
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Gert de Pagter",
                    "email": "BackEndTea@gmail.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill for ctype functions",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "ctype",
                "polyfill",
                "portable"
            ],
            "support": {
                "source": "https://github.com/symfony/polyfill-ctype/tree/v1.31.0"
            },
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2024-09-09T11:45:10+00:00"
        },
        {
            "name": "symfony/polyfill-mbstring",
            "version": "v1.31.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-mbstring.git",
                "reference": "85181ba99b2345b0ef10ce42ecac37612d9fd341"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/85181ba99b2345b0ef10ce42ecac37612d9fd341",
                "reference": "85181ba99b2345b0ef10ce42ecac37612d9fd341",
                "shasum": ""
            },
            "require": {
                "php": ">=7.2"
            },
            "provide": {
                "ext-mbstring": "*"
            },
            "suggest": {
                "ext-mbstring": "For best performance"
            },
            "type": "library",
            "extra": {
                "thanks": {
                    "name": "symfony/polyfill",
                    "url": "https://github.com/symfony/polyfill"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ],
                "psr-4": {
                    "Symfony\\Polyfill\\Mbstring\\": ""
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Nicolas Grekas",
                    "email": "p@tchwork.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill for the Mbstring extension",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "mbstring",
                "polyfill",
                "portable",
                "shim"
            ],
            "support": {
                "source": "https://github.com/symfony/polyfill-mbstring/tree/v1.31.0"
            },
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2024-09-09T11:45:10+00:00"
        },
        {
            "name": "symfony/polyfill-php80",
            "version": "v1.31.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-php80.git",
                "reference": "60328e362d4c2c802a54fcbf04f9d3fb892b4cf8"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-php80/zipball/60328e362d4c2c802a54fcbf04f9d3fb892b4cf8",
                "reference": "60328e362d4c2c802a54fcbf04f9d3fb892b4cf8",
                "shasum": ""
            },
            "require": {
                "php": ">=7.2"
            },
            "type": "library",
            "extra": {
                "thanks": {
                    "name": "symfony/polyfill",
                    "url": "https://github.com/symfony/polyfill"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ],
                "psr-4": {
                    "Symfony\\Polyfill\\Php80\\": ""
                },
                "classmap": [
                    "Resources/stubs"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Ion Bazan",
                    "email": "ion.bazan@gmail.com"
                },
                {
                    "name": "Nicolas Grekas",
                    "email": "p@tchwork.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill backporting some PHP 8.0+ features to lower PHP versions",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "polyfill",
                "portable",
                "shim"
            ],
            "support": {
                "source": "https://github.com/symfony/polyfill-php80/tree/v1.31.0"
            },
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2024-09-09T11:45:10+00:00"
        },
        {
            "name": "vlucas/phpdotenv",
            "version": "v5.6.1",
            "source": {
                "type": "git",
                "url": "https://github.com/vlucas/phpdotenv.git",
                "reference": "a59a13791077fe3d44f90e7133eb68e7d22eaff2"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/vlucas/phpdotenv/zipball/a59a13791077fe3d44f90e7133eb68e7d22eaff2",
                "reference": "a59a13791077fe3d44f90e7133eb68e7d22eaff2",
                "shasum": ""
            },
            "require": {
                "ext-pcre": "*",
                "graham-campbell/result-type": "^1.1.3",
                "php": "^7.2.5 || ^8.0",
                "phpoption/phpoption": "^1.9.3",
                "symfony/polyfill-ctype": "^1.24",
                "symfony/polyfill-mbstring": "^1.24",
                "symfony/polyfill-php80": "^1.24"
            },
            "require-dev": {
                "bamarni/composer-bin-plugin": "^1.8.2",
                "ext-filter": "*",
                "phpunit/phpunit": "^8.5.34 || ^9.6.13 || ^10.4.2"
            },
            "suggest": {
                "ext-filter": "Required to use the boolean validator."
            },
            "type": "library",
            "extra": {
                "bamarni-bin": {
                    "bin-links": true,
                    "forward-command": false
                },
                "branch-alias": {
                    "dev-master": "5.6-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Dotenv\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Graham Campbell",
                    "email": "hello@gjcampbell.co.uk",
                    "homepage": "https://github.com/GrahamCampbell"
                },
                {
                    "name": "Vance Lucas",
                    "email": "vance@vancelucas.com",
                    "homepage": "https://github.com/vlucas"
                }
            ],
            "description": "Loads environment variables from `.env` to `getenv()`, `$_ENV` and `$_SERVER` automagically.",
            "keywords": [
                "dotenv",
                "env",
                "environment"
            ],
            "support": {
                "issues": "https://github.com/vlucas/phpdotenv/issues",
                "source": "https://github.com/vlucas/phpdotenv/tree/v5.6.1"
            },
            "funding": [
                {
                    "url": "https://github.com/GrahamCampbell",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/vlucas/phpdotenv",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-20T21:52:34+00:00"
        }
    ],
    "packages-dev": [],
    "aliases": [],
    "minimum-stability": "stable",
    "stability-flags": {},
    "prefer-stable": false,
    "prefer-lowest": false,
    "platform": {
        "php": "^8.1"
    },
    "platform-dev": {},
    "plugin-api-version": "2.6.0"
}
=== ./backend/.env.example ===
DB_HOST=localhost
DB_PORT=3306
DB_DATABASE=pawpath
DB_USERNAME=root
DB_PASSWORD=

APP_ENV=development
APP_DEBUG=true
APP_KEY=base64:your-secret-key-here

# If you're using JWT for authentication
JWT_SECRET=your-jwt-secret-key-here
=== ./pawpath_contents.txt ===
=== ./.gitignore ===
# Dependencies
/frontend/node_modules
/backend/vendor
/backend/composer.lock
package-lock.json
yarn.lock

# Environment files
.env
.env.local
.env.*.local

# IDE files
.idea/
.vscode/
*.sublime-project
*.sublime-workspace

# Build files
/frontend/build
/frontend/dist
/public/hot
/public/storage

# Debug logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
*.log

# System files
.DS_Store
Thumbs.db

# Testing
/coverage
/phpunit.xml
.phpunit.result.cache

# Temporary files
*.swp
*.swo
*.tmp
*.temp

# Database
*.sqlite
*.sqlite3
=== ./frontend/index.html ===
=== ./README.md ===
# PawPath - Pet Adoption Database and Community Platform

## Overview
PawPath is a centralized platform that aggregates data from various shelters to streamline the pet adoption process and support animal welfare.

## Features
- Pet adoption database
- Community features
- Educational content
- Shelter management system
- Onboarding quiz for potential adopters

## Technology Stack
- Frontend: [To be decided]
- Backend: PHP, [Other technologies to be decided]
- Database: [To be decided]

## Getting Started
[Instructions on how to set up the project locally]

## Contributing
[Guidelines for contributing to the project]

## License
This project is licensed under the [Your chosen license] License - see the [LICENSE.md](LICENSE.md) file for details.
